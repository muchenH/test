<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>飞机大战 | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="项目实战 —— 飞机大战目标 强化 面向对象 程序设计 体验使用 pygame 模块进行 游戏开发  实战步骤 pygame 快速体验 飞机大战 实战  确认模块 —— pygame pygame 就是一个 Python 模块，专为电子游戏设计 官方网站：https:&#x2F;&#x2F;www.pygame.org&#x2F; 提示：要学习第三方模块，通常最好的参考资料就在官方网站       网站栏目 内容    Get">
<meta property="og:type" content="article">
<meta property="og:title" content="飞机大战">
<meta property="og:url" content="http://example.com/2021/10/10/%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="项目实战 —— 飞机大战目标 强化 面向对象 程序设计 体验使用 pygame 模块进行 游戏开发  实战步骤 pygame 快速体验 飞机大战 实战  确认模块 —— pygame pygame 就是一个 Python 模块，专为电子游戏设计 官方网站：https:&#x2F;&#x2F;www.pygame.org&#x2F; 提示：要学习第三方模块，通常最好的参考资料就在官方网站       网站栏目 内容    Get">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-10-10T14:09:45.000Z">
<meta property="article:modified_time" content="2021-10-10T14:20:20.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="pygame">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/10/10/%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '飞机大战',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-10 22:20:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">飞机大战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-10-10T14:09:45.000Z" title="Created 2021-10-10 22:09:45">2021-10-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-10-10T14:20:20.000Z" title="Updated 2021-10-10 22:20:20">2021-10-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/">项目实战</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="飞机大战"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="项目实战-——-飞机大战"><a href="#项目实战-——-飞机大战" class="headerlink" title="项目实战 —— 飞机大战"></a>项目实战 —— 飞机大战</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>强化 <strong>面向对象</strong> 程序设计</li>
<li>体验使用 <code>pygame</code> 模块进行 <strong>游戏开发</strong></li>
</ul>
<h2 id="实战步骤"><a href="#实战步骤" class="headerlink" title="实战步骤"></a>实战步骤</h2><ol>
<li><code>pygame</code> 快速体验</li>
<li><strong>飞机大战</strong> 实战</li>
</ol>
<h2 id="确认模块-——-pygame"><a href="#确认模块-——-pygame" class="headerlink" title="确认模块 —— pygame"></a>确认模块 —— pygame</h2><ul>
<li><code>pygame</code> 就是一个 Python 模块，专为电子游戏设计</li>
<li>官方网站：<a target="_blank" rel="noopener" href="https://www.pygame.org/">https://www.pygame.org/</a><ul>
<li><strong>提示</strong>：要学习第三方模块，通常最好的参考资料就在官方网站</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>网站栏目</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td><code>GettingStarted</code></td>
<td>在各平台安装模块的说明</td>
</tr>
<tr>
<td><code>Docs</code></td>
<td><code>pygame</code> 模块所有 <strong>类</strong> 和 <strong>子类</strong> 的参考手册</td>
</tr>
</tbody></table>
<h3 id="安装-pygame"><a href="#安装-pygame" class="headerlink" title="安装 pygame"></a>安装 pygame</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip3 install pygame</span><br></pre></td></tr></table></figure>

<h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -m pygame.examples.aliens</span><br></pre></td></tr></table></figure>


<h1 id="pygame-快速入门"><a href="#pygame-快速入门" class="headerlink" title="pygame 快速入门"></a>pygame 快速入门</h1><h2 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h2><ol>
<li>项目准备</li>
<li>使用 <code>pygame</code> 创建图形窗口</li>
<li>理解 <strong>图像</strong> 并实现图像绘制</li>
<li>理解 <strong>游戏循环</strong> 和 <strong>游戏时钟</strong></li>
<li>理解 <strong>精灵</strong> 和 <strong>精灵组</strong></li>
</ol>
<h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><ol>
<li>新建 <strong>飞机大战</strong> 项目</li>
<li>新建一个 <code>hm_01_pygame入门.py</code></li>
<li>导入 <strong>游戏素材图片</strong></li>
</ol>
<p><strong>游戏的第一印象</strong></p>
<ul>
<li>把一些 <strong>静止的图像</strong> 绘制到 <strong>游戏窗口</strong> 中</li>
<li>根据 <strong>用户的交互</strong> 或其他情况，<strong>移动</strong> 这些图像，产生动画效果</li>
<li>根据 <strong>图像之间</strong> 是否发生重叠，判断 <strong>敌机是否被摧毁</strong> 等其他情况</li>
</ul>
<h2 id="01-使用-pygame-创建图形窗口"><a href="#01-使用-pygame-创建图形窗口" class="headerlink" title="01. 使用 pygame 创建图形窗口"></a>01. 使用 <code>pygame</code> 创建图形窗口</h2><h3 id="小节目标"><a href="#小节目标" class="headerlink" title="小节目标"></a>小节目标</h3><ol>
<li>游戏的初始化和退出</li>
<li>理解游戏中的坐标系</li>
<li>创建游戏主窗口</li>
<li>简单的游戏循环</li>
</ol>
<blockquote>
<p>可以将图片素材 <strong>绘制</strong> 到 <strong>游戏的窗口</strong> 上，开发游戏之前需要先知道 <strong>如何建立游戏窗口</strong>！</p>
</blockquote>
<h3 id="1-1-游戏的初始化和退出"><a href="#1-1-游戏的初始化和退出" class="headerlink" title="1.1 游戏的初始化和退出"></a>1.1 游戏的初始化和退出</h3><ul>
<li>要使用 <code>pygame</code> 提供的所有功能之前，需要调用 <code>init</code> 方法</li>
<li>在游戏结束前需要调用一下 <code>quit</code> 方法</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>pygame.init()</code></td>
<td>导入并初始化所有 <code>pygame</code> 模块，使用其他模块之前，必须先调用 <code>init</code> 方法</td>
</tr>
<tr>
<td><code>pygame.quit()</code></td>
<td>卸载所有 <code>pygame</code> 模块，在游戏结束之前调用！</td>
</tr>
</tbody></table>
<p><img src="/media/15025046487919/001_pygame%E7%9A%84init%E5%92%8Cquit.png" alt="001_pygame的init和quit-w254"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line">pygame.init()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 游戏代码...</span></span><br><span class="line"></span><br><span class="line">pygame.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-2-理解游戏中的坐标系"><a href="#1-2-理解游戏中的坐标系" class="headerlink" title="1.2 理解游戏中的坐标系"></a>1.2 理解游戏中的坐标系</h3><ul>
<li><strong>坐标系</strong><ul>
<li><strong>原点</strong> 在 <strong>左上角</strong> <code>(0, 0)</code></li>
<li><strong>x 轴</strong> 水平方向向 <strong>右</strong>，逐渐增加</li>
<li><strong>y 轴</strong> 垂直方向向 <strong>下</strong>，逐渐增加</li>
</ul>
</li>
</ul>
<p><img src="/media/15025046487919/002_%E6%B8%B8%E6%88%8F%E7%AA%97%E5%8F%A3%E5%92%8C%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt="002_游戏窗口和坐标系-w300"></p>
<ul>
<li><p>在游戏中，<strong>所有可见的元素</strong> 都是以 <strong>矩形区域</strong> 来描述位置的</p>
<ul>
<li>要描述一个矩形区域有四个要素：<code>(x, y) (width, height)</code></li>
</ul>
</li>
<li><p><code>pygame</code> 专门提供了一个类 <code>pygame.Rect</code> 用于描述 <strong>矩形区域</strong></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rect(x, y, width, height) -&gt; Rect</span><br></pre></td></tr></table></figure>

<p><img src="/media/15025046487919/003_pygame.Rect.png" alt="003_pygame.Rect-w382"></p>
<p><strong>提示</strong></p>
<ul>
<li><code>pygame.Rect</code> 是一个比较特殊的类，内部只是封装了一些数字计算</li>
<li>不执行 <code>pygame.init()</code> 方法同样能够直接使用</li>
</ul>
<h4 id="案例演练"><a href="#案例演练" class="headerlink" title="案例演练"></a>案例演练</h4><p><strong>需求</strong></p>
<ol>
<li>定义 <code>hero_rect</code> 矩形描述 <strong>英雄的位置和大小</strong></li>
<li>输出英雄的 <strong>坐标原点</strong>（<code>x</code> 和 <code>y</code>）</li>
<li>输出英雄的 <strong>尺寸</strong>（<strong>宽度</strong> 和 <strong>高度</strong>）</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hero_rect = pygame.Rect(<span class="number">100</span>, <span class="number">500</span>, <span class="number">120</span>, <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;坐标原点 %d %d&quot;</span> % (hero_rect.x, hero_rect.y))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;英雄大小 %d %d&quot;</span> % (hero_rect.width, hero_rect.height))</span><br><span class="line"><span class="comment"># size 属性会返回矩形区域的 (宽, 高) 元组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;英雄大小 %d %d&quot;</span> % hero_rect.size)</span><br></pre></td></tr></table></figure>

<h3 id="1-3-创建游戏主窗口"><a href="#1-3-创建游戏主窗口" class="headerlink" title="1.3 创建游戏主窗口"></a>1.3 创建游戏主窗口</h3><ul>
<li><code>pygame</code> 专门提供了一个 <strong>模块</strong> <code>pygame.display</code> 用于创建、管理 <strong>游戏窗口</strong></li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>pygame.display.set_mode()</code></td>
<td>初始化游戏显示窗口</td>
</tr>
<tr>
<td><code>pygame.display.update()</code></td>
<td>刷新屏幕内容显示，稍后使用</td>
</tr>
</tbody></table>
<p><strong><code>set_mode</code> 方法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_mode(resolution=(<span class="number">0</span>,<span class="number">0</span>), flags=<span class="number">0</span>, depth=<span class="number">0</span>) -&gt; Surface</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>作用</strong> —— 创建游戏显示窗口</p>
</li>
<li><p><strong>参数</strong></p>
<ul>
<li><code>resolution</code> 指定屏幕的 <code>宽</code> 和 <code>高</code>，默认创建的窗口大小和屏幕大小一致</li>
<li><code>flags</code> 参数指定屏幕的附加选项，例如是否全屏等等，默认不需要传递</li>
<li><code>depth</code> 参数表示颜色的位数，默认自动匹配</li>
</ul>
</li>
<li><p><strong>返回值</strong></p>
<ul>
<li><strong>暂时</strong> 可以理解为 <strong>游戏的屏幕</strong>，<strong>游戏的元素</strong> 都需要被绘制到 <strong>游戏的屏幕</strong> 上</li>
</ul>
</li>
<li><p><strong>注意</strong>：必须使用变量记录 <code>set_mode</code> 方法的返回结果！因为：后续所有的图像绘制都基于这个返回结果</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建游戏主窗口</span></span><br><span class="line">screen = pygame.display.set_mode((<span class="number">480</span>, <span class="number">700</span>))</span><br></pre></td></tr></table></figure>

<h3 id="1-4-简单的游戏循环"><a href="#1-4-简单的游戏循环" class="headerlink" title="1.4 简单的游戏循环"></a>1.4 简单的游戏循环</h3><ul>
<li>为了做到游戏程序启动后，<strong>不会立即退出</strong>，通常会在游戏程序中增加一个 <strong>游戏循环</strong></li>
<li>所谓 <strong>游戏循环</strong> 就是一个 <strong>无限循环</strong></li>
<li>在 <strong>创建游戏窗口</strong> 代码下方，增加一个无限循环<ul>
<li>注意：<strong>游戏窗口不需要重复创建</strong></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建游戏主窗口</span></span><br><span class="line">screen = pygame.display.set_mode((<span class="number">480</span>, <span class="number">700</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 游戏循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="02-理解-图像-并实现图像绘制"><a href="#02-理解-图像-并实现图像绘制" class="headerlink" title="02. 理解 图像 并实现图像绘制"></a>02. 理解 <strong>图像</strong> 并实现图像绘制</h2><ul>
<li>在游戏中，能够看到的 <strong>游戏元素</strong> 大多都是 <strong>图像</strong><ul>
<li><strong>图像文件</strong> 初始是保存在磁盘上的，如果需要使用，<strong>第一步</strong> 就需要 <strong>被加载到内存</strong></li>
</ul>
</li>
<li>要在屏幕上 <strong>看到某一个图像的内容</strong>，需要按照三个步骤：<ol>
<li>使用 <code>pygame.image.load()</code> <strong>加载图像的数据</strong></li>
<li>使用 <strong>游戏屏幕</strong> 对象，调用 <code>blit</code> 方法 将图像绘制到指定位置</li>
<li>调用 <code>pygame.display.update()</code> 方法更新整个屏幕的显示</li>
</ol>
</li>
</ul>
<p><img src="/media/15025046487919/004_%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%83%8F.png" alt="004_加载和显示图像-w841"></p>
<blockquote>
<p>提示：要想在屏幕上看到绘制的结果，就一定要调用 <code>pygame.display.update()</code> 方法</p>
</blockquote>
<h3 id="代码演练-I-——-绘制背景图像"><a href="#代码演练-I-——-绘制背景图像" class="headerlink" title="代码演练 I —— 绘制背景图像"></a>代码演练 I —— 绘制背景图像</h3><p><strong>需求</strong></p>
<ol>
<li>加载 <code>background.png</code> 创建背景</li>
<li>将 <strong>背景</strong> 绘制在屏幕的 <code>(0, 0)</code> 位置</li>
<li>调用屏幕更新显示背景图像</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制背景图像</span></span><br><span class="line"><span class="comment"># 1&gt; 加载图像</span></span><br><span class="line">bg = pygame.image.load(<span class="string">&quot;./images/background.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2&gt; 绘制在屏幕</span></span><br><span class="line">screen.blit(bg, (<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3&gt; 更新显示</span></span><br><span class="line">pygame.display.update()</span><br></pre></td></tr></table></figure>

<h3 id="代码演练-II-——-绘制英雄图像"><a href="#代码演练-II-——-绘制英雄图像" class="headerlink" title="代码演练 II —— 绘制英雄图像"></a>代码演练 II —— 绘制英雄图像</h3><p><strong>需求</strong></p>
<ol>
<li>加载 <code>me1.png</code> 创建英雄飞机</li>
<li>将 <strong>英雄飞机</strong> 绘制在屏幕的 <code>(200, 500)</code> 位置</li>
<li>调用屏幕更新显示飞机图像</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1&gt; 加载图像</span></span><br><span class="line">hero = pygame.image.load(<span class="string">&quot;./images/me1.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2&gt; 绘制在屏幕</span></span><br><span class="line">screen.blit(hero, (<span class="number">200</span>, <span class="number">500</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3&gt; 更新显示</span></span><br><span class="line">pygame.display.update()</span><br></pre></td></tr></table></figure>

<p><strong>透明图像</strong> </p>
<ul>
<li><code>png</code> 格式的图像是支持 <strong>透明</strong> 的</li>
<li>在绘制图像时，<strong>透明区域</strong> 不会显示任何内容</li>
<li>但是如果<strong>下方已经有内容</strong>，会 <strong>透过</strong> <strong>透明区域</strong> 显示出来</li>
</ul>
<h3 id="理解-update-方法的作用"><a href="#理解-update-方法的作用" class="headerlink" title="理解 update() 方法的作用"></a>理解 <code>update()</code> 方法的作用</h3><blockquote>
<p>可以在 <code>screen</code> 对象完成 <strong>所有</strong> <code>blit</code> 方法之后，<strong>统一调用一次</strong> <code>display.update</code> 方法，同样可以在屏幕上 <strong>看到最终的绘制结果</strong></p>
</blockquote>
<ul>
<li>使用 <code>display.set_mode()</code> 创建的 <code>screen</code> <strong>对象</strong> 是一个 <strong>内存中的屏幕数据对象</strong><ul>
<li>可以理解成是 <strong>油画</strong> 的 <strong>画布</strong></li>
</ul>
</li>
<li><code>screen.blit</code> 方法可以在 <strong>画布</strong> 上绘制很多 <strong>图像</strong><ul>
<li>例如：<strong>英雄</strong>、<strong>敌机</strong>、<strong>子弹</strong>…</li>
<li><strong>这些图像</strong> 有可能 会彼此 <strong>重叠或者覆盖</strong></li>
</ul>
</li>
<li><code>display.update()</code> 会将 <strong>画布</strong> 的 <strong>最终结果</strong> 绘制在屏幕上，这样可以 <strong>提高屏幕绘制效率</strong>，<strong>增加游戏的流畅度</strong></li>
</ul>
<p><strong>案例调整</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制背景图像</span></span><br><span class="line"><span class="comment"># 1&gt; 加载图像</span></span><br><span class="line">bg = pygame.image.load(<span class="string">&quot;./images/background.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2&gt; 绘制在屏幕</span></span><br><span class="line">screen.blit(bg, (<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制英雄图像</span></span><br><span class="line"><span class="comment"># 1&gt; 加载图像</span></span><br><span class="line">hero = pygame.image.load(<span class="string">&quot;./images/me1.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2&gt; 绘制在屏幕</span></span><br><span class="line">screen.blit(hero, (<span class="number">200</span>, <span class="number">500</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3&gt; 更新显示 - update 方法会把之前所有绘制的结果，一次性更新到屏幕窗口上</span></span><br><span class="line">pygame.display.update()</span><br></pre></td></tr></table></figure>

<h2 id="03-理解-游戏循环-和-游戏时钟"><a href="#03-理解-游戏循环-和-游戏时钟" class="headerlink" title="03. 理解 游戏循环 和 游戏时钟"></a>03. 理解 <strong>游戏循环</strong> 和 <strong>游戏时钟</strong></h2><blockquote>
<p>现在 <strong>英雄飞机</strong> 已经被绘制到屏幕上了，<strong>怎么能够让飞机移动呢</strong> ？</p>
</blockquote>
<h3 id="3-1-游戏中的动画实现原理"><a href="#3-1-游戏中的动画实现原理" class="headerlink" title="3.1 游戏中的动画实现原理"></a>3.1 游戏中的动画实现原理</h3><ul>
<li>跟 <strong>电影</strong> 的原理类似，游戏中的动画效果，本质上是 <strong>快速</strong> 的在屏幕上绘制 <strong>图像</strong><ul>
<li>电影是将多张 <strong>静止的电影胶片</strong> <strong>连续、快速</strong>的播放，产生连贯的视觉效果！</li>
</ul>
</li>
<li>一般在电脑上 <strong>每秒绘制 60 次</strong>，就能够达到非常 <strong>连续</strong> <strong>高品质</strong> 的动画效果<ul>
<li>每次绘制的结果被称为 <strong>帧 Frame</strong></li>
</ul>
</li>
</ul>
<p><img src="/media/15025046487919/%E6%89%8B%E7%BF%BB%E4%B9%A6%E5%8A%A8%E7%94%BB.gif" alt="手翻书动画"><br><img src="/media/15025046487919/%E7%8C%AB%E6%83%8A%E8%AE%B6.gif" alt="猫惊讶"></p>
<h3 id="3-2-游戏循环"><a href="#3-2-游戏循环" class="headerlink" title="3.2 游戏循环"></a>3.2 <strong>游戏循环</strong></h3><h4 id="游戏的两个组成部分"><a href="#游戏的两个组成部分" class="headerlink" title="游戏的两个组成部分"></a>游戏的两个组成部分</h4><blockquote>
<p><strong>游戏循环的开始</strong> 就意味着 <strong>游戏的正式开始</strong></p>
</blockquote>
<p><img src="/media/15025046487919/005_%E6%B8%B8%E6%88%8F%E4%B8%BB%E6%A8%A1%E5%9D%97.png" alt="005_游戏主模块-w600"></p>
<h4 id="游戏循环的作用"><a href="#游戏循环的作用" class="headerlink" title="游戏循环的作用"></a>游戏循环的作用</h4><ol>
<li>保证游戏 <strong>不会直接退出</strong></li>
<li><strong>变化图像位置</strong> —— 动画效果<ul>
<li>每隔 <code>1 / 60 秒</code> 移动一下所有图像的位置</li>
<li>调用 <code>pygame.display.update()</code> 更新屏幕显示</li>
</ul>
</li>
<li><strong>检测用户交互</strong> —— 按键、鼠标等…</li>
</ol>
<h3 id="3-3-游戏时钟"><a href="#3-3-游戏时钟" class="headerlink" title="3.3 游戏时钟"></a>3.3 游戏时钟</h3><ul>
<li><code>pygame</code> 专门提供了一个类 <code>pygame.time.Clock</code> 可以非常方便的设置屏幕绘制速度 —— <strong>刷新帧率</strong></li>
<li>要使用 <strong>时钟对象</strong> 需要两步：<ul>
<li>1）在 <strong>游戏初始化</strong> 创建一个 <strong>时钟对象</strong></li>
<li>2）在 <strong>游戏循环</strong> 中让时钟对象调用 <code>tick(帧率)</code> 方法</li>
</ul>
</li>
<li><code>tick</code> 方法会根据 <strong>上次被调用的时间</strong>，自动设置 <strong>游戏循环</strong> 中的延时</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. 创建游戏时钟对象</span></span><br><span class="line">clock = pygame.time.Clock()</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 游戏循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置屏幕刷新帧率</span></span><br><span class="line">    clock.tick(<span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-英雄的简单动画实现"><a href="#3-4-英雄的简单动画实现" class="headerlink" title="3.4 英雄的简单动画实现"></a>3.4 英雄的简单动画实现</h3><p><strong>需求</strong></p>
<ol>
<li>在 <strong>游戏初始化</strong> 定义一个 <code>pygame.Rect</code> 的变量记录英雄的初始位置</li>
<li>在 <strong>游戏循环</strong> 中每次让 <strong>英雄</strong> 的 <code>y - 1</code> —— 向上移动 </li>
<li><code>y &lt;= 0</code> 将英雄移动到屏幕的底部</li>
</ol>
<blockquote>
<p>提示：</p>
<ul>
<li>每一次调用 <code>update()</code> 方法之前，需要把 <strong>所有的游戏图像都重新绘制一遍</strong></li>
<li>而且应该 <strong>最先</strong> 重新绘制 <strong>背景图像</strong></li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. 定义英雄的初始位置</span></span><br><span class="line">hero_rect = pygame.Rect(<span class="number">150</span>, <span class="number">500</span>, <span class="number">102</span>, <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可以指定循环体内部的代码执行的频率</span></span><br><span class="line">    clock.tick(<span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新英雄位置</span></span><br><span class="line">    hero_rect.y -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果移出屏幕，则将英雄的顶部移动到屏幕底部</span></span><br><span class="line">    <span class="keyword">if</span> hero_rect.y &lt;= <span class="number">0</span>:</span><br><span class="line">        hero_rect.y = <span class="number">700</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制背景图片</span></span><br><span class="line">    screen.blit(bg, (<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="comment"># 绘制英雄图像</span></span><br><span class="line">    screen.blit(hero, hero_rect)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新显示</span></span><br><span class="line">    pygame.display.update()</span><br></pre></td></tr></table></figure>

<h4 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h4><ol>
<li>英雄向上飞行，当 <strong>英雄完全从上方飞出屏幕后</strong></li>
<li>将飞机移动到屏幕的底部</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> hero_rect.y + hero_rect.height &lt;= <span class="number">0</span>:</span><br><span class="line">    hero_rect.y = <span class="number">700</span></span><br></pre></td></tr></table></figure>

<p><strong>提示</strong></p>
<ul>
<li><code>Rect</code> 的属性 <code>bottom = y + height</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> hero_rect.bottom &lt;= <span class="number">0</span>:</span><br><span class="line">    hero_rect.y = <span class="number">700</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-在游戏循环中-监听-事件"><a href="#3-5-在游戏循环中-监听-事件" class="headerlink" title="3.5 在游戏循环中 监听 事件"></a>3.5 在游戏循环中 监听 事件</h3><h4 id="事件-event"><a href="#事件-event" class="headerlink" title="事件 event"></a>事件 <code>event</code></h4><ul>
<li>就是游戏启动后，<strong>用户针对游戏所做的操作</strong></li>
<li>例如：<strong>点击关闭按钮</strong>，<strong>点击鼠标</strong>，<strong>按下键盘</strong>…</li>
</ul>
<h4 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h4><ul>
<li>在 <strong>游戏循环</strong> 中，判断用户 <strong>具体的操作</strong></li>
</ul>
<blockquote>
<p>只有 <strong>捕获</strong> 到用户具体的操作，才能有针对性的做出响应</p>
</blockquote>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul>
<li><code>pygame</code> 中通过 <code>pygame.event.get()</code> 可以获得 <strong>用户当前所做动作</strong> 的 <strong>事件列表</strong><ul>
<li>用户可以同一时间做很多事情</li>
</ul>
</li>
<li>提示：<strong>这段代码非常的固定</strong>，几乎所有的 <code>pygame</code> 游戏都 <strong>大同小异</strong>！</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 游戏循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置屏幕刷新帧率</span></span><br><span class="line">    clock.tick(<span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 事件监听</span></span><br><span class="line">    <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断用户是否点击了关闭按钮</span></span><br><span class="line">        <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.QUIT:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;退出游戏...&quot;</span>)</span><br><span class="line"></span><br><span class="line">            pygame.quit()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 直接退出系统</span></span><br><span class="line">            exit()</span><br></pre></td></tr></table></figure>

<h2 id="04-理解-精灵-和-精灵组"><a href="#04-理解-精灵-和-精灵组" class="headerlink" title="04. 理解 精灵 和 精灵组"></a>04. 理解 <strong>精灵</strong> 和 <strong>精灵组</strong></h2><h3 id="4-1-精灵-和-精灵组"><a href="#4-1-精灵-和-精灵组" class="headerlink" title="4.1 精灵 和 精灵组"></a>4.1 精灵 和 精灵组</h3><ul>
<li>在刚刚完成的案例中，<strong>图像加载</strong>、<strong>位置变化</strong>、<strong>绘制图像</strong> 都需要程序员编写代码分别处理</li>
<li>为了简化开发步骤，<code>pygame</code> 提供了两个类<ul>
<li><code>pygame.sprite.Sprite</code> —— 存储 <strong>图像数据 image</strong> 和 <strong>位置 rect</strong> 的 <strong>对象</strong></li>
<li><code>pygame.sprite.Group</code></li>
</ul>
</li>
</ul>
<p><img src="/media/15025046487919/006_pygame.Sprite.png" alt="006_pygame.Sprite"></p>
<h4 id="精灵"><a href="#精灵" class="headerlink" title="精灵"></a>精灵</h4><ul>
<li><p>在游戏开发中，通常把 <strong>显示图像的对象</strong> 叫做精灵 <code>Sprite</code></p>
</li>
<li><p><strong>精灵</strong> 需要 有 <strong>两个重要的属性</strong></p>
<ul>
<li><code>image</code> 要显示的图像</li>
<li><code>rect</code> 图像要显示在屏幕的位置</li>
</ul>
</li>
<li><p>默认的 <code>update()</code> 方法什么事情也没做</p>
<ul>
<li>子类可以重写此方法，在每次刷新屏幕时，更新精灵位置</li>
</ul>
</li>
<li><p><strong>注意</strong>：<code>pygame.sprite.Sprite</code> 并没有提供 <code>image</code> 和 <code>rect</code> 两个属性</p>
<ul>
<li>需要程序员从 <code>pygame.sprite.Sprite</code> 派生子类</li>
<li>并在 <strong>子类</strong> 的 <strong>初始化方法</strong> 中，设置 <code>image</code> 和 <code>rect</code> 属性</li>
</ul>
</li>
</ul>
<h4 id="精灵组"><a href="#精灵组" class="headerlink" title="精灵组"></a>精灵组</h4><ul>
<li>一个 <strong>精灵组</strong> 可以包含多个 <strong>精灵</strong> 对象</li>
<li>调用 <strong>精灵组</strong> 对象的 <code>update()</code> 方法<ul>
<li>可以 <strong>自动</strong> 调用 <strong>组内每一个精灵</strong> 的 <code>update()</code> 方法</li>
</ul>
</li>
<li>调用 <strong>精灵组</strong> 对象的 <code>draw(屏幕对象)</code> 方法<ul>
<li>可以将 <strong>组内每一个精灵</strong> 的 <code>image</code> 绘制在 <code>rect</code> 位置</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Group(*sprites) -&gt; Group</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：仍然需要调用 <code>pygame.display.update()</code> 才能在屏幕看到最终结果</p>
</blockquote>
<h3 id="4-2-派生精灵子类"><a href="#4-2-派生精灵子类" class="headerlink" title="4.2 派生精灵子类"></a>4.2 派生精灵子类</h3><ol>
<li>新建 <code>plane_sprites.py</code> 文件</li>
<li>定义 <code>GameSprite</code> 继承自 <code>pygame.sprite.Sprite</code></li>
</ol>
<p><strong>注意</strong></p>
<ul>
<li>如果一个类的 <strong>父类</strong> 不是 <code>object</code></li>
<li>在重写 <strong>初始化方法</strong> 时，<strong>一定要</strong> 先 <code>super()</code> 一下父类的 <code>__init__</code> 方法</li>
<li><strong>保证父类中实现的 <code>__init__</code> 代码能够被正常执行</strong></li>
</ul>
<p><img src="/media/15025046487919/007_GameSprite.png" alt="007_GameSprite-w398"></p>
<p><strong>属性</strong></p>
<ul>
<li><code>image</code> 精灵图像，使用 <code>image_name</code> 加载</li>
<li><code>rect</code> 精灵大小，默认使用图像大小</li>
<li><code>speed</code> 精灵移动速度，默认为 <code>1</code></li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li><code>update</code> 每次更新屏幕时在游戏循环内调用<ul>
<li>让精灵的 <code>self.rect.y += self.speed</code></li>
</ul>
</li>
</ul>
<p><strong>提示</strong></p>
<ul>
<li><code>image</code> 的 <code>get_rect()</code> 方法，可以返回 <strong>pygame.Rect(0, 0, 图像宽, 图像高)</strong> 的对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameSprite</span>(pygame.sprite.Sprite):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;游戏精灵基类&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, image_name, speed=<span class="number">1</span></span>):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 调用父类的初始化方法</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 加载图像</span></span><br><span class="line">        self.image = pygame.image.load(image_name)</span><br><span class="line">        <span class="comment"># 设置尺寸</span></span><br><span class="line">        self.rect = self.image.get_rect()</span><br><span class="line">        <span class="comment"># 记录速度</span></span><br><span class="line">        self.speed = speed</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, *args</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 默认在垂直方向移动</span></span><br><span class="line">        self.rect.y += self.speed</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h3 id="4-3-使用-游戏精灵-和-精灵组-创建敌机"><a href="#4-3-使用-游戏精灵-和-精灵组-创建敌机" class="headerlink" title="4.3 使用 游戏精灵 和 精灵组 创建敌机"></a>4.3 使用 游戏精灵 和 精灵组 创建敌机</h3><p><strong>需求</strong></p>
<ul>
<li>使用刚刚派生的 <strong>游戏精灵</strong> 和 <strong>精灵组</strong> 创建 敌机 并且实现敌机动画</li>
</ul>
<p><strong>步骤</strong></p>
<ol>
<li>使用 <code>from</code> 导入 <code>plane_sprites</code> 模块 <ul>
<li><code>from</code> 导入的模块可以 <strong>直接使用</strong></li>
<li><code>import</code> 导入的模块需要通过 <strong>模块名.</strong> 来使用</li>
</ul>
</li>
<li>在 <strong>游戏初始化</strong> 创建 <strong>精灵对象</strong> 和 <strong>精灵组对象</strong></li>
<li>在 <strong>游戏循环中</strong> 让 <strong>精灵组</strong> 分别调用 <code>update()</code> 和 <code>draw(screen)</code> 方法</li>
</ol>
<p><strong>职责</strong></p>
<ul>
<li>精灵<ul>
<li>封装 <strong>图像 image</strong>、<strong>位置 rect</strong> 和 <strong>速度 speed</strong></li>
<li>提供 <code>update()</code> 方法，根据游戏需求，<strong>更新位置 rect</strong></li>
</ul>
</li>
<li>精灵组<ul>
<li>包含 <strong>多个</strong> <strong>精灵对象</strong></li>
<li><code>update</code> 方法，让精灵组中的所有精灵调用 <code>update</code> 方法更新位置</li>
<li><code>draw(screen)</code> 方法，在 <code>screen</code> 上绘制精灵组中的所有精灵</li>
</ul>
</li>
</ul>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ul>
<li><ol>
<li>导入 <code>plane_sprites</code> 模块</li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> plane_sprites <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="2">
<li>修改初始化部分代码</li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建敌机精灵和精灵组</span></span><br><span class="line">enemy1 = GameSprite(<span class="string">&quot;./images/enemy1.png&quot;</span>)</span><br><span class="line">enemy2 = GameSprite(<span class="string">&quot;./images/enemy1.png&quot;</span>, <span class="number">2</span>)</span><br><span class="line">enemy2.rect.x = <span class="number">200</span></span><br><span class="line">enemy_group = pygame.sprite.Group(enemy1, enemy2)</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="3">
<li>修改游戏循环部分代码</li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让敌机组调用 update 和 draw 方法</span></span><br><span class="line">enemy_group.update()</span><br><span class="line">enemy_group.draw(screen)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新屏幕显示</span></span><br><span class="line">pygame.display.update()</span><br></pre></td></tr></table></figure>

<h1 id="游戏框架搭建"><a href="#游戏框架搭建" class="headerlink" title="游戏框架搭建"></a>游戏框架搭建</h1><p><strong>目标</strong> —— 使用 <strong>面相对象</strong> 设计 <strong>飞机大战游戏类</strong></p>
<h2 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h2><ul>
<li>明确主程序职责</li>
<li>实现主程序类</li>
<li>准备游戏精灵组</li>
</ul>
<h2 id="01-明确主程序职责"><a href="#01-明确主程序职责" class="headerlink" title="01. 明确主程序职责"></a>01. 明确主程序职责</h2><ul>
<li>回顾 <strong>快速入门案例</strong>，一个游戏主程序的 <strong>职责</strong> 可以分为两个部分：<ul>
<li>游戏初始化</li>
<li>游戏循环</li>
</ul>
</li>
<li>根据明确的职责，设计 <code>PlaneGame</code> 类如下：</li>
</ul>
<p><img src="/media/15025159832322/009_%E6%B8%B8%E6%88%8F%E4%B8%BB%E7%A8%8B%E5%BA%8F.png" alt="009_游戏主程序-w600"></p>
<blockquote>
<p><strong>提示</strong> 根据 <strong>职责</strong> 封装私有方法，可以避免某一个方法的代码写得太过冗长</p>
<p>如果某一个方法编写的太长，既不好阅读，也不好维护！</p>
</blockquote>
<ul>
<li><strong>游戏初始化</strong> ——  <code>__init__()</code> 会调用以下方法：</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td><code>__create_sprites(self)</code></td>
<td>创建所有精灵和精灵组</td>
</tr>
</tbody></table>
<ul>
<li><strong>游戏循环</strong> —— <code>start_game()</code> 会调用以下方法：</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td><code>__event_handler(self)</code></td>
<td>事件监听</td>
</tr>
<tr>
<td><code>__check_collide(self)</code></td>
<td>碰撞检测 —— 子弹销毁敌机、敌机撞毁英雄</td>
</tr>
<tr>
<td><code>__update_sprites(self)</code></td>
<td>精灵组更新和绘制</td>
</tr>
<tr>
<td><code>__game_over()</code></td>
<td>游戏结束</td>
</tr>
</tbody></table>
<h2 id="02-实现飞机大战主游戏类"><a href="#02-实现飞机大战主游戏类" class="headerlink" title="02. 实现飞机大战主游戏类"></a>02. 实现飞机大战主游戏类</h2><h3 id="2-1-明确文件职责"><a href="#2-1-明确文件职责" class="headerlink" title="2.1 明确文件职责"></a>2.1 明确文件职责</h3><p><img src="/media/15025159832322/011_%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6%E8%81%8C%E8%B4%A3.png" alt="011_程序文件职责-w479"></p>
<ul>
<li><code>plane_main</code> <ol>
<li>封装 <strong>主游戏类</strong></li>
<li>创建 <strong>游戏对象</strong></li>
<li><strong>启动游戏</strong></li>
</ol>
</li>
<li><code>plane_sprites</code><ul>
<li>封装游戏中 <strong>所有</strong> 需要使用的 <strong>精灵子类</strong></li>
<li>提供游戏的 <strong>相关工具</strong></li>
</ul>
</li>
</ul>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><ul>
<li>新建 <code>plane_main.py</code> 文件，并且设置为可执行</li>
<li>编写 <strong>基础代码</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">from</span> plane_sprites <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlaneGame</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;飞机大战主游戏&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;游戏初始化&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_game</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;开始游戏...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建游戏对象</span></span><br><span class="line">    game = PlaneGame()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始游戏</span></span><br><span class="line">    game.start_game()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-3-游戏初始化部分"><a href="#2-3-游戏初始化部分" class="headerlink" title="2.3 游戏初始化部分"></a>2.3 游戏初始化部分</h3><ul>
<li>完成 <code>__init__()</code> 代码如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;游戏初始化&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1. 创建游戏的窗口</span></span><br><span class="line">    self.screen = pygame.display.set_mode((<span class="number">480</span>, <span class="number">700</span>))</span><br><span class="line">    <span class="comment"># 2. 创建游戏的时钟</span></span><br><span class="line">    self.clock = pygame.time.Clock()</span><br><span class="line">    <span class="comment"># 3. 调用私有方法，精灵和精灵组的创建</span></span><br><span class="line">    self.__create_sprites()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__create_sprites</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h4 id="使用-常量-代替固定的数值"><a href="#使用-常量-代替固定的数值" class="headerlink" title="使用 常量 代替固定的数值"></a>使用 常量 代替固定的数值</h4><blockquote>
<ul>
<li>常量 —— 不变化的量</li>
<li>变量 —— 可以变化的量</li>
</ul>
</blockquote>
<p><strong>应用场景</strong></p>
<ul>
<li>在开发时，可能会需要使用 <strong>固定的数值</strong>，例如 <strong>屏幕的高度</strong> 是 <code>700</code></li>
<li>这个时候，建议 <strong>不要</strong> 直接使用固定数值，而应该使用 <strong>常量</strong></li>
<li>在开发时，为了保证代码的可维护性，尽量不要使用 <strong>魔法数字</strong></li>
</ul>
<p><strong>常量的定义</strong></p>
<ul>
<li>定义 <strong>常量</strong> 和 定义 <strong>变量</strong> 的语法完全一样，都是使用 <strong>赋值语句</strong></li>
<li><strong>常量</strong> 的 <strong>命名</strong> 应该 <strong>所有字母都使用大写</strong>，<strong>单词与单词之间使用下划线连接</strong></li>
</ul>
<p><strong>常量的好处</strong></p>
<ul>
<li>阅读代码时，通过 <strong>常量名</strong> <strong>见名之意</strong>，不需要猜测数字的含义</li>
<li>如果需要 <strong>调整值</strong>，只需要 <strong>修改常量定义</strong> 就可以实现 <strong>统一修改</strong></li>
</ul>
<blockquote>
<p>提示：Python 中并没有真正意义的常量，只是通过命名的约定 —— 所有字母都是大写的就是常量，开发时不要轻易的修改！</p>
</blockquote>
<p><strong>代码调整</strong></p>
<ul>
<li>在 <code>plane_sprites.py</code> 中增加常量定义</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"><span class="comment"># 游戏屏幕大小</span></span><br><span class="line">SCREEN_RECT = pygame.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">480</span>, <span class="number">700</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>plane_main.py</code> 中的窗口大小</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.screen = pygame.display.set_mode(SCREEN_RECT.size)</span><br></pre></td></tr></table></figure>

<h3 id="2-4-游戏循环部分"><a href="#2-4-游戏循环部分" class="headerlink" title="2.4 游戏循环部分"></a>2.4 游戏循环部分</h3><ul>
<li>完成 <code>start_game()</code> 基础代码如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">start_game</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;开始游戏&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始游戏...&quot;</span>)</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 1. 设置刷新帧率</span></span><br><span class="line">        self.clock.tick(<span class="number">60</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 事件监听</span></span><br><span class="line">        self.__event_handler()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3. 碰撞检测</span></span><br><span class="line">        self.__check_collide()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 4. 更新精灵组</span></span><br><span class="line">        self.__update_sprites()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 5. 更新屏幕显示</span></span><br><span class="line">        pygame.display.update()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__event_handler</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;事件监听&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.QUIT:</span><br><span class="line">            PlaneGame.__game_over()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__check_collide</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;碰撞检测&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__update_sprites</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;更新精灵组&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__game_over</span>():</span><br><span class="line">   <span class="string">&quot;&quot;&quot;游戏结束&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;游戏结束&quot;</span>)</span><br><span class="line">   pygame.quit()</span><br><span class="line">   exit()</span><br></pre></td></tr></table></figure>

<h2 id="03-准备游戏精灵组"><a href="#03-准备游戏精灵组" class="headerlink" title="03. 准备游戏精灵组"></a>03. 准备游戏精灵组</h2><h3 id="3-1-确定精灵组"><a href="#3-1-确定精灵组" class="headerlink" title="3.1 确定精灵组"></a>3.1 确定精灵组</h3><p><img src="/media/15025159832322/010_%E7%B2%BE%E7%81%B5%E7%BB%84%E7%A1%AE%E5%AE%9A.png" alt="010_精灵组确定-w600"></p>
<h3 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h3><ul>
<li>创建精灵组方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__create_sprites</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建精灵组&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 背景组</span></span><br><span class="line">    self.back_group = pygame.sprite.Group()</span><br><span class="line">    <span class="comment"># 敌机组</span></span><br><span class="line">    self.enemy_group = pygame.sprite.Group()</span><br><span class="line">    <span class="comment"># 英雄组</span></span><br><span class="line">    self.hero_group = pygame.sprite.Group()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>更新精灵组方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__update_sprites</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;更新精灵组&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> group <span class="keyword">in</span> [self.back_group, self.enemy_group, self.hero_group]:</span><br><span class="line">    </span><br><span class="line">        group.update()</span><br><span class="line">        group.draw(self.screen)</span><br></pre></td></tr></table></figure>

<h1 id="游戏背景"><a href="#游戏背景" class="headerlink" title="游戏背景"></a>游戏背景</h1><h2 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h2><ul>
<li>背景交替滚动的思路确定</li>
<li>显示游戏背景</li>
</ul>
<h2 id="01-背景交替滚动的思路确定"><a href="#01-背景交替滚动的思路确定" class="headerlink" title="01. 背景交替滚动的思路确定"></a>01. 背景交替滚动的思路确定</h2><p>运行 <strong>备课代码</strong>，<strong>观察</strong> 背景图像的显示效果：</p>
<ul>
<li>游戏启动后，<strong>背景图像</strong> 会 <strong>连续不断地</strong> <strong>向下方</strong> 移动</li>
<li>在 <strong>视觉上</strong> 产生英雄的飞机不断向上方飞行的 <strong>错觉</strong> —— 在很多跑酷类游戏中常用的套路<ul>
<li><strong>游戏的背景</strong> 不断变化</li>
<li><strong>游戏的主角</strong> 位置保持不变</li>
</ul>
</li>
</ul>
<h3 id="1-1-实现思路分析"><a href="#1-1-实现思路分析" class="headerlink" title="1.1 实现思路分析"></a>1.1 实现思路分析</h3><p> <img src="/media/15025262948537/013_%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E4%BA%A4%E6%9B%BF%E6%BB%9A%E5%8A%A8.png" alt="013_背景图片交替滚动-w640"></p>
<p><strong>解决办法</strong></p>
<ol>
<li>创建两张背景图像精灵<ul>
<li>第 <code>1</code> 张 <strong>完全和屏幕重合</strong></li>
<li>第 <code>2</code> 张在 <strong>屏幕的正上方</strong></li>
</ul>
</li>
<li>两张图像 <strong>一起向下方运动</strong><ul>
<li><code>self.rect.y += self.speed</code></li>
</ul>
</li>
<li>当 <strong>任意背景精灵</strong> 的 <code>rect.y &gt;= 屏幕的高度</code> 说明已经 <strong>移动到屏幕下方</strong></li>
<li>将 <strong>移动到屏幕下方的这张图像</strong> 设置到 <strong>屏幕的正上方</strong><ul>
<li><code>rect.y = -rect.height</code></li>
</ul>
</li>
</ol>
<h3 id="1-2-设计背景类"><a href="#1-2-设计背景类" class="headerlink" title="1.2 设计背景类"></a>1.2 设计背景类</h3><p><img src="/media/15025262948537/012_%E6%B4%BE%E7%94%9FBackground%E5%AD%90%E7%B1%BB.png" alt="012_派生Background子类-w398"></p>
<ul>
<li><strong>初始化方法</strong><ul>
<li>直接指定 <strong>背景图片</strong></li>
<li><code>is_alt</code> 判断是否是另一张图像<ul>
<li><code>False</code> 表示 <strong>第一张图像</strong>，需要与屏幕重合</li>
<li><code>True</code> 表示 <strong>另一张图像</strong>，在屏幕的正上方</li>
</ul>
</li>
</ul>
</li>
<li><strong>update()</strong> 方法<ul>
<li>判断 <strong>是否移动出屏幕</strong>，如果是，将图像设置到 <strong>屏幕的正上方</strong>，从而实现 <strong>交替滚动</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>继承</strong> 如果父类提供的方法，不能满足子类的需求：</p>
<ul>
<li>派生一个子类</li>
<li>在子类中针对特有的需求，重写父类方法，并且进行扩展</li>
</ul>
</blockquote>
<h2 id="02-显示游戏背景"><a href="#02-显示游戏背景" class="headerlink" title="02. 显示游戏背景"></a>02. 显示游戏背景</h2><h3 id="2-1-背景精灵的基本实现"><a href="#2-1-背景精灵的基本实现" class="headerlink" title="2.1 背景精灵的基本实现"></a>2.1 背景精灵的基本实现</h3><ul>
<li>在 <code>plane_sprites</code> 新建 <code>Background</code> 继承自 <code>GameSprite</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Background</span>(<span class="title class_ inherited__">GameSprite</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;游戏背景精灵&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 调用父类的方法实现</span></span><br><span class="line">        <span class="built_in">super</span>().update()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 判断是否移出屏幕，如果移出屏幕，将图像设置到屏幕的上方</span></span><br><span class="line">        <span class="keyword">if</span> self.rect.y &gt;= SCREEN_RECT.height:</span><br><span class="line">            self.rect.y = -self.rect.height</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-2-在-plane-main-py-中显示背景精灵"><a href="#2-2-在-plane-main-py-中显示背景精灵" class="headerlink" title="2.2 在 plane_main.py 中显示背景精灵"></a>2.2 在 <code>plane_main.py</code> 中显示背景精灵</h3><ol>
<li>在 <code>__create_sprites</code> 方法中创建 <strong>精灵</strong> 和 <strong>精灵组</strong></li>
<li>在 <code>__update_sprites</code> 方法中，让 <strong>精灵组</strong> 调用 <code>update()</code> 和 <code>draw()</code> 方法</li>
</ol>
<blockquote>
<p><code>__create_sprites</code> 方法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__create_sprites</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建背景精灵和精灵组</span></span><br><span class="line">    bg1 = Background(<span class="string">&quot;./images/background.png&quot;</span>)</span><br><span class="line">    bg2 = Background(<span class="string">&quot;./images/background.png&quot;</span>)</span><br><span class="line">    bg2.rect.y = -bg2.rect.height</span><br><span class="line">    </span><br><span class="line">    self.back_group = pygame.sprite.Group(bg1, bg2)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>__update_sprites</code> 方法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__update_sprites</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">    self.back_group.update()</span><br><span class="line">    self.back_group.draw(self.screen)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-利用初始化方法，简化背景精灵创建"><a href="#2-3-利用初始化方法，简化背景精灵创建" class="headerlink" title="2.3 利用初始化方法，简化背景精灵创建"></a>2.3 利用初始化方法，简化背景精灵创建</h3><blockquote>
<p>思考 —— 上一小结完成的代码存在什么样的问题？能否简化？</p>
</blockquote>
<ul>
<li>在主程序中，创建的<strong>两个背景精灵</strong>，<strong>传入了相同的图像文件路径</strong></li>
<li>创建 <strong>第二个 背景精灵</strong> 时，<strong>在主程序中</strong>，设置背景精灵的图像位置</li>
</ul>
<blockquote>
<p>思考 —— 精灵 <strong>初始位置</strong> 的设置，应该 <strong>由主程序负责</strong>？还是 <strong>由精灵自己负责</strong>？</p>
</blockquote>
<p><strong>答案</strong> —— <strong>由精灵自己负责</strong></p>
<ul>
<li>根据面向对象设计原则，应该将对象的职责，封装到类的代码内部</li>
<li>尽量简化程序调用一方的代码调用</li>
</ul>
<p><img src="/media/15025262948537/012_%E6%B4%BE%E7%94%9FBackground%E5%AD%90%E7%B1%BB.png" alt="012_派生Background子类-w398"></p>
<ul>
<li><strong>初始化方法</strong><ul>
<li>直接指定 <strong>背景图片</strong></li>
<li><code>is_alt</code> 判断是否是另一张图像<ul>
<li><code>False</code> 表示 <strong>第一张图像</strong>，需要与屏幕重合</li>
<li><code>True</code> 表示 <strong>另一张图像</strong>，在屏幕的正上方</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在 <code>plane_sprites.py</code> 中实现 <code>Background</code> 的 <strong>初始化方法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, is_alt=<span class="literal">False</span></span>):</span><br><span class="line"></span><br><span class="line">    image_name = <span class="string">&quot;./images/background.png&quot;</span></span><br><span class="line">    <span class="built_in">super</span>().__init__(image_name)</span><br><span class="line">       </span><br><span class="line">    <span class="comment"># 判断是否交替图片，如果是，将图片设置到屏幕顶部</span></span><br><span class="line">    <span class="keyword">if</span> is_alt:</span><br><span class="line">        self.rect.y = -self.rect.height     </span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>plane_main</code> 的 <code>__create_sprites</code> 方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建背景精灵和精灵组</span></span><br><span class="line">bg1 = Background()</span><br><span class="line">bg2 = Background(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">self.back_group = pygame.sprite.Group(bg1, bg2)</span><br></pre></td></tr></table></figure>


<h1 id="敌机出场"><a href="#敌机出场" class="headerlink" title="敌机出场"></a>敌机出场</h1><h2 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h2><ul>
<li>使用 <strong>定时器</strong> 添加敌机</li>
<li>设计 <code>Enemy</code> 类</li>
</ul>
<h2 id="01-使用定时器添加敌机"><a href="#01-使用定时器添加敌机" class="headerlink" title="01. 使用定时器添加敌机"></a>01. 使用定时器添加敌机</h2><p>运行 <strong>备课代码</strong>，<strong>观察</strong> 敌机的 <strong>出现规律</strong>：</p>
<ol>
<li>游戏启动后，<strong>每隔 1 秒</strong> 会 <strong>出现一架敌机</strong></li>
<li>每架敌机 <strong>向屏幕下方飞行</strong>，飞行 <strong>速度各不相同</strong></li>
<li>每架敌机出现的 <strong>水平位置</strong> 也不尽相同</li>
<li>当敌机 <strong>从屏幕下方飞出</strong>，不会再飞回到屏幕中</li>
</ol>
<h3 id="1-1-定时器"><a href="#1-1-定时器" class="headerlink" title="1.1 定时器"></a>1.1 定时器</h3><ul>
<li>在 <code>pygame</code> 中可以使用 <code>pygame.time.set_timer()</code> 来添加 <strong>定时器</strong></li>
<li>所谓 <strong>定时器</strong>，就是 <strong>每隔一段时间</strong>，去 <strong>执行一些动作</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_timer(eventid, milliseconds) -&gt; <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>set_timer</code> 可以创建一个 <strong>事件</strong></li>
<li>可以在 <strong>游戏循环</strong> 的 <strong>事件监听</strong> 方法中捕获到该事件</li>
<li>第 1 个参数 <strong>事件代号</strong> 需要基于常量 <code>pygame.USEREVENT</code> 来指定<ul>
<li><code>USEREVENT</code> 是一个整数，再增加的事件可以使用 <code>USEREVENT + 1</code> 指定，依次类推…</li>
</ul>
</li>
<li>第 2 个参数是 <strong>事件触发</strong> 间隔的 <strong>毫秒值</strong></li>
</ul>
<p><strong>定时器事件的监听</strong></p>
<ul>
<li>通过 <code>pygame.event.get()</code> 可以获取当前时刻所有的 <strong>事件列表</strong></li>
<li><strong>遍历列表</strong> 并且判断 <code>event.type</code> 是否等于 <code>eventid</code>，如果相等，表示 <strong>定时器事件</strong> 发生</li>
</ul>
<h3 id="1-2-定义并监听创建敌机的定时器事件"><a href="#1-2-定义并监听创建敌机的定时器事件" class="headerlink" title="1.2 定义并监听创建敌机的定时器事件"></a>1.2 定义并监听创建敌机的定时器事件</h3><p><code>pygame</code> 的 <strong>定时器</strong> 使用套路非常固定：</p>
<ol>
<li>定义 <strong>定时器常量</strong> —— <code>eventid</code></li>
<li>在 <strong>初始化方法</strong> 中，调用 <code>set_timer</code> 方法 <strong>设置定时器事件</strong></li>
<li>在 <strong>游戏循环</strong> 中，<strong>监听定时器事件</strong></li>
</ol>
<h4 id="1-定义事件"><a href="#1-定义事件" class="headerlink" title="1) 定义事件"></a>1) 定义事件</h4><ul>
<li>在 <code>plane_sprites.py</code> 的顶部定义 <strong>事件常量</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 敌机的定时器事件常量</span></span><br><span class="line">CREATE_ENEMY_EVENT = pygame.USEREVENT</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>PlaneGame</code> 的 <strong>初始化方法</strong> 中 <strong>创建用户事件</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. 设置定时器事件 - 每秒创建一架敌机</span></span><br><span class="line">pygame.time.set_timer(CREATE_ENEMY_EVENT, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-监听定时器事件"><a href="#2-监听定时器事件" class="headerlink" title="2) 监听定时器事件"></a>2) 监听定时器事件</h4><ul>
<li>在 <code>__event_handler</code> 方法中增加以下代码：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__event_handler</span>(<span class="params">self</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 判断是否退出游戏</span></span><br><span class="line">        <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.QUIT:</span><br><span class="line">            PlaneGame.__game_over()</span><br><span class="line">        <span class="keyword">elif</span> event.<span class="built_in">type</span> == CREATE_ENEMY_EVENT:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;敌机出场...&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="02-设计-Enemy-类"><a href="#02-设计-Enemy-类" class="headerlink" title="02. 设计 Enemy 类"></a>02. 设计 <code>Enemy</code> 类</h2><ol>
<li>游戏启动后，<strong>每隔 1 秒</strong> 会 <strong>出现一架敌机</strong></li>
<li>每架敌机 <strong>向屏幕下方飞行</strong>，飞行 <strong>速度各不相同</strong></li>
<li>每架敌机出现的 <strong>水平位置</strong> 也不尽相同</li>
<li>当敌机 <strong>从屏幕下方飞出</strong>，不会再飞回到屏幕中</li>
</ol>
<p><img src="/media/15025309517247/014_%E6%B4%BE%E7%94%9FEnemy%E5%AD%90%E7%B1%BB.png" alt="014_派生Enemy子类-w657"></p>
<ul>
<li><strong>初始化方法</strong><ul>
<li>指定 <strong>敌机图片</strong></li>
<li><strong>随机</strong> 敌机的 <strong>初始位置</strong> 和 <strong>初始速度</strong></li>
</ul>
</li>
<li>重写 <strong>update()</strong> 方法<ul>
<li>判断 <strong>是否飞出屏幕</strong>，如果是，从 <strong>精灵组</strong> 删除</li>
</ul>
</li>
</ul>
<h3 id="2-1-敌机类的准备"><a href="#2-1-敌机类的准备" class="headerlink" title="2.1 敌机类的准备"></a>2.1 敌机类的准备</h3><ul>
<li>在 <code>plane_sprites</code> 新建 <code>Enemy</code> 继承自 <code>GameSprite</code></li>
<li>重写 <strong>初始化方法</strong>，直接指定 <strong>图片名称</strong></li>
<li>暂时 <strong>不实现</strong> <strong>随机速度</strong> 和 <strong>随机位置</strong> 的指定</li>
<li>重写 <code>update</code> 方法，判断是否飞出屏幕</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Enemy</span>(<span class="title class_ inherited__">GameSprite</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;敌机精灵&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1. 调用父类方法，创建敌机精灵，并且指定敌机的图像</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="string">&quot;./images/enemy1.png&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 设置敌机的随机初始速度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 设置敌机的随机初始位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1. 调用父类方法，让敌机在垂直方向运动</span></span><br><span class="line">        <span class="built_in">super</span>().update()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 判断是否飞出屏幕，如果是，需要将敌机从精灵组删除</span></span><br><span class="line">        <span class="keyword">if</span> self.rect.y &gt;= SCREEN_RECT.height:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;敌机飞出屏幕...&quot;</span>)    </span><br></pre></td></tr></table></figure>

<h3 id="2-2-创建敌机"><a href="#2-2-创建敌机" class="headerlink" title="2.2 创建敌机"></a>2.2 创建敌机</h3><p><strong>演练步骤</strong></p>
<ol>
<li>在 <code>__create_sprites</code>，添加 <strong>敌机精灵组</strong><ul>
<li>敌机是 <strong>定时被创建的</strong>，因此在初始化方法中，不需要创建敌机</li>
</ul>
</li>
<li>在 <code>__event_handler</code>，创建敌机，并且 <strong>添加到精灵组</strong><ul>
<li>调用 <strong>精灵组</strong> 的 <code>add</code> 方法可以 <strong>向精灵组添加精灵</strong></li>
</ul>
</li>
<li>在 <code>__update_sprites</code>，让 <strong>敌机精灵组</strong> 调用 <code>update</code> 和 <code>draw</code> 方法</li>
</ol>
<p><img src="/media/15025309517247/006_pygame.SpriteII.png" alt="006_pygame.SpriteII"></p>
<p><strong>演练代码</strong></p>
<ul>
<li>修改 <code>plane_main</code> 的 <code>__create_sprites</code> 方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 敌机组</span></span><br><span class="line">self.enemy_group = pygame.sprite.Group()</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>plane_main</code> 的 <code>__update_sprites</code> 方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.enemy_group.update()</span><br><span class="line">self.enemy_group.draw(self.screen)</span><br></pre></td></tr></table></figure>

<ul>
<li>定时出现敌机</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> event.<span class="built_in">type</span> == CREATE_ENEMY_EVENT:</span><br><span class="line">    self.enemy_group.add(Enemy())</span><br></pre></td></tr></table></figure>

<h3 id="2-3-随机敌机位置和速度"><a href="#2-3-随机敌机位置和速度" class="headerlink" title="2.3 随机敌机位置和速度"></a>2.3 随机敌机位置和速度</h3><h4 id="1-导入模块"><a href="#1-导入模块" class="headerlink" title="1) 导入模块"></a>1) 导入模块</h4><ul>
<li>在导入模块时，<strong>建议</strong> 按照以下顺序导入</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 官方标准模块导入</span><br><span class="line"><span class="number">2.</span> 第三方模块导入</span><br><span class="line"><span class="number">3.</span> 应用程序模块导入</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>plane_sprites.py</code> 增加 <code>random</code> 的导入</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br></pre></td></tr></table></figure>

<h4 id="2-随机位置"><a href="#2-随机位置" class="headerlink" title="2) 随机位置"></a>2) 随机位置</h4><p><img src="/media/15025309517247/015_%E9%A3%9E%E6%9C%BA%E5%88%9D%E5%A7%8B%E4%BD%8D%E7%BD%AE.png" alt="015_飞机初始位置-w360"></p>
<p>使用 <code>pygame.Rect</code> 提供的 <code>bottom</code> 属性，在指定敌机初始位置时，会比较方便</p>
<ul>
<li><code>bottom = y + height</code></li>
<li><code>y = bottom - height</code></li>
</ul>
<h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3) 代码实现"></a>3) 代码实现</h4><ul>
<li>修改 <strong>初始化方法</strong>，随机敌机出现 <strong>速度</strong> 和 <strong>位置</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 调用父类方法，创建敌机精灵，并且指定敌机的图像</span></span><br><span class="line">    <span class="built_in">super</span>().__init__(<span class="string">&quot;./images/enemy1.png&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 设置敌机的随机初始速度 1 ~ 3</span></span><br><span class="line">    self.speed = random.randint(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 设置敌机的随机初始位置</span></span><br><span class="line">    self.rect.bottom = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    max_x = SCREEN_RECT.width - self.rect.width</span><br><span class="line">    self.rect.x = random.randint(<span class="number">0</span>, max_x)</span><br></pre></td></tr></table></figure>

<h3 id="2-4-移出屏幕销毁敌机"><a href="#2-4-移出屏幕销毁敌机" class="headerlink" title="2.4 移出屏幕销毁敌机"></a>2.4 移出屏幕销毁敌机</h3><ul>
<li>敌机移出屏幕之后，如果 <strong>没有撞到英雄</strong>，敌机的历史使命已经终结</li>
<li>需要从 <strong>敌机组</strong> 删除，否则会造成 <strong>内存浪费</strong></li>
</ul>
<h4 id="检测敌机被销毁"><a href="#检测敌机被销毁" class="headerlink" title="检测敌机被销毁"></a>检测敌机被销毁</h4><ul>
<li><code>__del__</code> 内置方法会在对象被销毁前调用，在开发中，可以用于 <strong>判断对象是否被销毁</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;敌机挂了 %s&quot;</span> % self.rect)</span><br></pre></td></tr></table></figure>

<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p><img src="/media/15025309517247/006_pygame.SpriteII.png" alt="006_pygame.SpriteII"></p>
<ul>
<li>判断敌机是否飞出屏幕，如果是，调用 <code>kill()</code> 方法从所有组中删除</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">super</span>().update()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 判断敌机是否移出屏幕</span></span><br><span class="line">    <span class="keyword">if</span> self.rect.y &gt;= SCREEN_RECT.height:</span><br><span class="line">        <span class="comment"># 将精灵从所有组中删除</span></span><br><span class="line">        self.kill()</span><br></pre></td></tr></table></figure>



<h1 id="英雄登场"><a href="#英雄登场" class="headerlink" title="英雄登场"></a>英雄登场</h1><h2 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h2><ul>
<li>设计 <strong>英雄</strong> 和 <strong>子弹</strong> 类</li>
<li>使用 <code>pygame.key.get_pressed()</code> 移动英雄</li>
<li>发射子弹</li>
</ul>
<h2 id="01-设计-英雄-和-子弹-类"><a href="#01-设计-英雄-和-子弹-类" class="headerlink" title="01. 设计 英雄 和 子弹 类"></a>01. 设计 <strong>英雄</strong> 和 <strong>子弹</strong> 类</h2><h3 id="英雄需求"><a href="#英雄需求" class="headerlink" title="英雄需求"></a>英雄需求</h3><ol>
<li>游戏启动后，<strong>英雄</strong> 出现在屏幕的 <strong>水平中间</strong> 位置，距离 <strong>屏幕底部</strong> <code>120</code> <strong>像素</strong></li>
<li><strong>英雄</strong> 每隔 <code>0.5</code> 秒发射一次子弹，每次 <strong>连发三枚子弹</strong></li>
<li><strong>英雄</strong> 默认不会移动，需要通过 <strong>左&#x2F;右</strong> 方向键，控制 <strong>英雄</strong> 在水平方向移动</li>
</ol>
<p><img src="/media/15025349250200/017_%E8%8B%B1%E9%9B%84%E4%BD%8D%E7%BD%AE.png" alt="017_英雄位置-w480"></p>
<h3 id="子弹需求"><a href="#子弹需求" class="headerlink" title="子弹需求"></a>子弹需求</h3><ol>
<li><strong>子弹</strong> 从 <strong>英雄</strong> 的正上方发射 <strong>沿直线</strong> 向 <strong>上方</strong> 飞行</li>
<li><strong>飞出屏幕后</strong>，需要从 <strong>精灵组</strong> 中删除</li>
</ol>
<p><img src="/media/15025349250200/016_%E6%B4%BE%E7%94%9F%E8%8B%B1%E9%9B%84%E5%92%8C%E5%AD%90%E5%BC%B9%E5%AD%90%E7%B1%BB.png" alt="016_派生英雄和子弹子类"></p>
<h3 id="Hero-——-英雄"><a href="#Hero-——-英雄" class="headerlink" title="Hero —— 英雄"></a>Hero —— 英雄</h3><ul>
<li><strong>初始化方法</strong><ul>
<li>指定 <strong>英雄图片</strong></li>
<li><strong>初始速度 &#x3D; 0</strong> —— 英雄默认静止不动</li>
<li>定义 <code>bullets</code> <strong>子弹精灵组</strong> 保存子弹精灵</li>
</ul>
</li>
<li>重写 <strong>update()</strong> 方法<ul>
<li>英雄需要 <strong>水平移动</strong></li>
<li>并且需要保证不能 <strong>移出屏幕</strong></li>
</ul>
</li>
<li>增加 <code>bullets</code> 属性，记录所有 <strong>子弹精灵</strong></li>
<li>增加 <code>fire</code> 方法，用于发射子弹</li>
</ul>
<h3 id="Bullet-——-子弹"><a href="#Bullet-——-子弹" class="headerlink" title="Bullet —— 子弹"></a>Bullet —— 子弹</h3><ul>
<li><strong>初始化方法</strong><ul>
<li>指定 <strong>子弹图片</strong></li>
<li><strong>初始速度 &#x3D; -2</strong> —— 子弹需要向上方飞行</li>
</ul>
</li>
<li>重写 <strong>update()</strong> 方法<ul>
<li>判断 <strong>是否飞出屏幕</strong>，如果是，从 <strong>精灵组</strong> 删除</li>
</ul>
</li>
</ul>
<h2 id="02-创建英雄"><a href="#02-创建英雄" class="headerlink" title="02. 创建英雄"></a>02. 创建英雄</h2><h3 id="2-1-准备英雄类"><a href="#2-1-准备英雄类" class="headerlink" title="2.1 准备英雄类"></a>2.1 准备英雄类</h3><ul>
<li>在 <code>plane_sprites</code> 新建 <code>Hero</code> 类</li>
<li>重写 <strong>初始化方法</strong>，直接指定 <strong>图片名称</strong>，并且将初始速度设置为 <code>0</code></li>
<li>设置 <strong>英雄的初始位置</strong></li>
</ul>
<p><img src="/media/15025349250200/003_pygame.Rect.png" alt="003_pygame.Rect-w382"></p>
<ul>
<li><code>centerx = x + 0.5 * width</code></li>
<li><code>centery = y + 0.5 * height</code></li>
<li><code>bottom = y + height</code></li>
</ul>
<p><img src="/media/15025349250200/017_%E8%8B%B1%E9%9B%84%E4%BD%8D%E7%BD%AE.png" alt="017_英雄位置-w480"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>(<span class="title class_ inherited__">GameSprite</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;英雄精灵&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="string">&quot;./images/me1.png&quot;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置初始位置</span></span><br><span class="line">        self.rect.centerx = SCREEN_RECT.centerx</span><br><span class="line">        self.rect.bottom = SCREEN_RECT.bottom - <span class="number">120</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-绘制英雄"><a href="#2-2-绘制英雄" class="headerlink" title="2.2 绘制英雄"></a>2.2 绘制英雄</h3><ol>
<li>在 <code>__create_sprites</code>，添加 <strong>英雄精灵</strong> 和 <strong>英雄精灵组</strong><ul>
<li>后续要针对 <strong>英雄</strong> 做 <strong>碰撞检测</strong> 以及 <strong>发射子弹</strong></li>
<li>所以 <strong>英雄</strong> 需要 <strong>单独定义成属性</strong></li>
</ul>
</li>
<li>在 <code>__update_sprites</code>，让 <strong>英雄精灵组</strong> 调用 <code>update</code> 和 <code>draw</code> 方法</li>
</ol>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><ul>
<li>修改 <code>__create_sprites</code> 方法如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 英雄组</span></span><br><span class="line">self.hero = Hero()</span><br><span class="line">self.hero_group = pygame.sprite.Group(self.hero)</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>__update_sprites</code> 方法如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.hero_group.update()</span><br><span class="line">self.hero_group.draw(self.screen)</span><br></pre></td></tr></table></figure>

<h2 id="03-移动英雄位置"><a href="#03-移动英雄位置" class="headerlink" title="03. 移动英雄位置"></a>03. 移动英雄位置</h2><blockquote>
<p>在 <code>pygame</code> 中针对 <strong>键盘按键的捕获</strong>，有 <strong>两种</strong> 方式</p>
</blockquote>
<ul>
<li><strong>第一种方式</strong> 判断 <code>event.type == pygame.KEYDOWN</code></li>
<li><strong>第二种方式</strong> <ol>
<li>首先使用 <code>pygame.key.get_pressed()</code> 返回 <strong>所有按键元组</strong></li>
<li>通过 <strong>键盘常量</strong>，判断元组中 <strong>某一个键是否被按下</strong> —— 如果被按下，对应数值为 <code>1</code></li>
</ol>
</li>
</ul>
<p><strong>提问</strong> 这两种方式之间有什么区别呢？</p>
<ul>
<li>第一种方式</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> event.<span class="built_in">type</span> == pygame.KEYDOWN <span class="keyword">and</span> event.key == pygame.K_RIGHT:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;向右移动...&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>第二种方式</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回所有按键的元组，如果某个键被按下，对应的值会是1</span></span><br><span class="line">keys_pressed = pygame.key.get_pressed()</span><br><span class="line"><span class="comment"># 判断是否按下了方向键</span></span><br><span class="line"><span class="keyword">if</span> keys_pressed[pygame.K_RIGHT]:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;向右移动...&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong></p>
<ul>
<li><strong>第一种方式</strong> <code>event.type</code> 用户 <strong>必须要抬起按键</strong> 才算一次 <strong>按键事件</strong>，<strong>操作灵活性会大打折扣</strong></li>
<li><strong>第二种方式</strong> 用户可以按住方向键不放，就能够实现持续向某一个方向移动了，<strong>操作灵活性更好</strong></li>
</ul>
<h3 id="3-1-移动英雄位置"><a href="#3-1-移动英雄位置" class="headerlink" title="3.1 移动英雄位置"></a>3.1 移动英雄位置</h3><p><strong>演练步骤</strong></p>
<ol>
<li>在 <code>Hero</code> 类中重写 <code>update</code> 方法<ul>
<li>用 <strong>速度</strong> <code>speed</code> 和 <strong>英雄</strong> <code>rect.x</code> 进行叠加</li>
<li><strong>不需要调用父类方法</strong> —— 父类方法只是实现了单纯的垂直运动</li>
</ul>
</li>
<li>在 <code>__event_handler</code> 方法中根据 <strong>左右方向键</strong> 设置英雄的 <strong>速度</strong><ul>
<li><strong>向右</strong> &#x3D;&gt; <code>speed = 2</code></li>
<li><strong>向左</strong> &#x3D;&gt; <code>speed = -2</code></li>
<li><strong>其他</strong> &#x3D;&gt; <code>speed = 0</code></li>
</ul>
</li>
</ol>
<p><strong>代码演练</strong></p>
<ul>
<li>在 <code>Hero</code> 类，重写 <code>update()</code> 方法，<strong>根据速度水平移动</strong> 英雄的飞机</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 飞机水平移动</span></span><br><span class="line">    self.rect.x += self.speed</span><br></pre></td></tr></table></figure>

<ul>
<li>调整键盘按键代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取用户按键</span></span><br><span class="line">keys_pressed = pygame.key.get_pressed()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> keys_pressed[pygame.K_RIGHT]:</span><br><span class="line">    self.hero.speed = <span class="number">2</span></span><br><span class="line"><span class="keyword">elif</span> keys_pressed[pygame.K_LEFT]:</span><br><span class="line">    self.hero.speed = -<span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.hero.speed = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-控制英雄运动边界"><a href="#3-2-控制英雄运动边界" class="headerlink" title="3.2 控制英雄运动边界"></a>3.2 控制英雄运动边界</h3><ul>
<li>在 <code>Hero</code> 类的 <code>update()</code> 方法判断 <strong>英雄</strong> 是否超出 <strong>屏幕边界</strong></li>
</ul>
<p><img src="/media/15025349250200/003_pygame.Rect.png" alt="003_pygame.Rect-w382"></p>
<ul>
<li><code>right = x + width</code> 利用 <code>right</code> 属性可以非常容易的针对右侧设置精灵位置</li>
</ul>
<p><img src="/media/15025349250200/017_%E8%8B%B1%E9%9B%84%E4%BD%8D%E7%BD%AEII.png" alt="017_英雄位置II-w408"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 飞机水平移动</span></span><br><span class="line">    self.rect.x += self.speed</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 判断屏幕边界</span></span><br><span class="line">    <span class="keyword">if</span> self.rect.left &lt; <span class="number">0</span>:</span><br><span class="line">        self.rect.left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> self.rect.right &gt; SCREEN_RECT.right:</span><br><span class="line">        self.rect.right = SCREEN_RECT.right</span><br></pre></td></tr></table></figure>

<h2 id="04-发射子弹"><a href="#04-发射子弹" class="headerlink" title="04. 发射子弹"></a>04. 发射子弹</h2><h3 id="需求回顾-——-英雄需求"><a href="#需求回顾-——-英雄需求" class="headerlink" title="需求回顾 —— 英雄需求"></a>需求回顾 —— 英雄需求</h3><ol>
<li>游戏启动后，<strong>英雄</strong> 出现在屏幕的 <strong>水平中间</strong> 位置，距离 <strong>屏幕底部</strong> <code>120</code> <strong>像素</strong></li>
<li><strong>英雄</strong> 每隔 <code>0.5</code> 秒发射一次子弹，每次 <strong>连发三枚子弹</strong></li>
<li><strong>英雄</strong> 默认不会移动，需要通过 <strong>左&#x2F;右</strong> 方向键，控制 <strong>英雄</strong> 在水平方向移动</li>
</ol>
<h3 id="4-1-添加发射子弹事件"><a href="#4-1-添加发射子弹事件" class="headerlink" title="4.1 添加发射子弹事件"></a>4.1 添加发射子弹事件</h3><p><code>pygame</code> 的 <strong>定时器</strong> 使用套路非常固定：</p>
<ol>
<li>定义 <strong>定时器常量</strong> —— <code>eventid</code></li>
<li>在 <strong>初始化方法</strong> 中，调用 <code>set_timer</code> 方法 <strong>设置定时器事件</strong></li>
<li>在 <strong>游戏循环</strong> 中，<strong>监听定时器事件</strong></li>
</ol>
<p><strong>代码实现</strong></p>
<ul>
<li>在 <code>Hero</code> 中定义 <code>fire</code> 方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fire</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;发射子弹...&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>plane_main.py</code> 的顶部定义 <strong>发射子弹</strong> 事件常量</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 英雄发射子弹事件</span></span><br><span class="line">HERO_FIRE_EVENT = pygame.USEREVENT + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>__init__</code> 方法末尾中添加 <strong>发射子弹</strong> 事件</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔 0.5 秒发射一次子弹</span></span><br><span class="line">pygame.time.set_timer(HERO_FIRE_EVENT, <span class="number">500</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>__event_handler</code> 方法中让英雄发射子弹</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> event.<span class="built_in">type</span> == HERO_FIRE_EVENT:</span><br><span class="line">    self.hero.fire()</span><br></pre></td></tr></table></figure>

<h3 id="4-2-定义子弹类"><a href="#4-2-定义子弹类" class="headerlink" title="4.2 定义子弹类"></a>4.2 定义子弹类</h3><h4 id="需求回顾-——-子弹需求"><a href="#需求回顾-——-子弹需求" class="headerlink" title="需求回顾 —— 子弹需求"></a>需求回顾 —— 子弹需求</h4><ol>
<li><strong>子弹</strong> 从 <strong>英雄</strong> 的正上方发射 <strong>沿直线</strong> 向 <strong>上方</strong> 飞行</li>
<li><strong>飞出屏幕后</strong>，需要从 <strong>精灵组</strong> 中删除</li>
</ol>
<h4 id="Bullet-——-子弹-1"><a href="#Bullet-——-子弹-1" class="headerlink" title="Bullet —— 子弹"></a>Bullet —— 子弹</h4><ul>
<li><strong>初始化方法</strong><ul>
<li>指定 <strong>子弹图片</strong></li>
<li><strong>初始速度 &#x3D; -2</strong> —— 子弹需要向上方飞行</li>
</ul>
</li>
<li>重写 <strong>update()</strong> 方法<ul>
<li>判断 <strong>是否飞出屏幕</strong>，如果是，从 <strong>精灵组</strong> 删除</li>
</ul>
</li>
</ul>
<h4 id="定义子弹类"><a href="#定义子弹类" class="headerlink" title="定义子弹类"></a>定义子弹类</h4><ul>
<li>在 <code>plane_sprites</code> 新建 <code>Bullet</code> 继承自 <code>GameSprite</code></li>
<li>重写 <strong>初始化方法</strong>，直接指定 <strong>图片名称</strong>，并且设置 <strong>初始速度</strong></li>
<li>重写 <code>update()</code> 方法，判断子弹 <strong>飞出屏幕从精灵组删除</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bullet</span>(<span class="title class_ inherited__">GameSprite</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;子弹精灵&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="string">&quot;./images/bullet1.png&quot;</span>, -<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">super</span>().update()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 判断是否超出屏幕，如果是，从精灵组删除</span></span><br><span class="line">        <span class="keyword">if</span> self.rect.bottom &lt; <span class="number">0</span>:</span><br><span class="line">            self.kill()</span><br></pre></td></tr></table></figure>

<h3 id="4-3-发射子弹"><a href="#4-3-发射子弹" class="headerlink" title="4.3 发射子弹"></a>4.3 发射子弹</h3><p><strong>演练步骤</strong></p>
<ol>
<li>在 <code>Hero</code> 的 <strong>初始化方法</strong> 中创建 <strong>子弹精灵组</strong> 属性</li>
<li>修改 <code>plane_main.py</code> 的 <code>__update_sprites</code> 方法，让 <strong>子弹精灵组</strong> 调用 <code>update</code> 和 <code>draw</code> 方法</li>
<li>实现 <code>fire()</code> 方法<ul>
<li>创建子弹精灵</li>
<li>设置初始位置 —— 在 <strong>英雄的正上方</strong></li>
<li>将 <strong>子弹</strong> 添加到精灵组</li>
</ul>
</li>
</ol>
<p><strong>代码实现</strong></p>
<ul>
<li>初始化方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建子弹的精灵组</span></span><br><span class="line">self.bullets = pygame.sprite.Group()</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>fire()</code> 方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fire</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 创建子弹精灵</span></span><br><span class="line">    bullet = Bullet()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 设置精灵的位置</span></span><br><span class="line">    bullet.rect.bottom = self.rect.y - <span class="number">20</span></span><br><span class="line">    bullet.rect.centerx = self.rect.centerx</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 将精灵添加到精灵组</span></span><br><span class="line">    self.bullets.add(bullet)</span><br></pre></td></tr></table></figure>

<h4 id="一次发射三枚子弹"><a href="#一次发射三枚子弹" class="headerlink" title="一次发射三枚子弹"></a>一次发射三枚子弹</h4><p><img src="/media/15025349250200/017_%E8%8B%B1%E9%9B%84%E4%BD%8D%E7%BD%AEIII.png" alt="017_英雄位置III-w559"></p>
<ul>
<li>修改 <code>fire()</code> 方法，一次发射三枚子弹</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fire</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>):</span><br><span class="line">        <span class="comment"># 1. 创建子弹精灵</span></span><br><span class="line">        bullet = Bullet()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 设置精灵的位置</span></span><br><span class="line">        bullet.rect.bottom = self.rect.y - i * <span class="number">20</span></span><br><span class="line">        bullet.rect.centerx = self.rect.centerx</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3. 将精灵添加到精灵组</span></span><br><span class="line">        self.bullets.add(bullet)</span><br></pre></td></tr></table></figure>

<h1 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h1><h2 id="目标-6"><a href="#目标-6" class="headerlink" title="目标"></a>目标</h2><ul>
<li>了解碰撞检测方法</li>
<li>碰撞实现</li>
</ul>
<h2 id="01-了解碰撞检测方法"><a href="#01-了解碰撞检测方法" class="headerlink" title="01. 了解碰撞检测方法"></a>01. 了解碰撞检测方法</h2><ul>
<li><code>pygame</code> 提供了 <strong>两个非常方便</strong> 的方法可以实现碰撞检测：</li>
</ul>
<h3 id="pygame-sprite-groupcollide"><a href="#pygame-sprite-groupcollide" class="headerlink" title="pygame.sprite.groupcollide()"></a>pygame.sprite.groupcollide()</h3><ul>
<li><strong>两个精灵组</strong> 中 <strong>所有的精灵</strong> 的碰撞检测</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupcollide(group1, group2, dokill1, dokill2, collided = <span class="literal">None</span>) -&gt; Sprite_dict</span><br></pre></td></tr></table></figure>

<ul>
<li>如果将 <code>dokill</code> 设置为 <code>True</code>，则 <strong>发生碰撞的精灵将被自动移除</strong></li>
<li><code>collided</code> 参数是用于 <strong>计算碰撞的回调函数</strong><ul>
<li>如果没有指定，则每个精灵必须有一个 <code>rect</code> 属性</li>
</ul>
</li>
</ul>
<h3 id="pygame-sprite-spritecollide"><a href="#pygame-sprite-spritecollide" class="headerlink" title="pygame.sprite.spritecollide()"></a>pygame.sprite.spritecollide()</h3><ul>
<li>判断 <strong>某个精灵</strong> 和 <strong>指定精灵组</strong> 中的精灵的碰撞</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spritecollide(sprite, group, dokill, collided = <span class="literal">None</span>) -&gt; Sprite_list</span><br></pre></td></tr></table></figure>

<ul>
<li>如果将 <code>dokill</code> 设置为 <code>True</code>，则 <strong>指定精灵组</strong> 中 <strong>发生碰撞的精灵将被自动移除</strong></li>
<li><code>collided</code> 参数是用于 <strong>计算碰撞的回调函数</strong><ul>
<li>如果没有指定，则每个精灵必须有一个 <code>rect</code> 属性</li>
</ul>
</li>
<li>返回 <strong>精灵组</strong> 中跟 <strong>精灵</strong> 发生碰撞的 <strong>精灵列表</strong></li>
</ul>
<h2 id="02-碰撞实现"><a href="#02-碰撞实现" class="headerlink" title="02. 碰撞实现"></a>02. 碰撞实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__check_collide</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 子弹摧毁敌机</span></span><br><span class="line">    pygame.sprite.groupcollide(self.hero.bullets, self.enemy_group, <span class="literal">True</span>, <span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 敌机撞毁英雄</span></span><br><span class="line">    enemies = pygame.sprite.spritecollide(self.hero, self.enemy_group, <span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 判断列表时候有内容</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(enemies) &gt; <span class="number">0</span>:</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 让英雄牺牲</span></span><br><span class="line">        self.hero.kill()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 结束游戏</span></span><br><span class="line">        PlaneGame.__game_over()</span><br></pre></td></tr></table></figure>


</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/10/10/%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98/">http://example.com/2021/10/10/%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pygame/">pygame</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/20/hello-world/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Hello World</div></div></a></div><div class="next-post pull-right"><a href="/2021/09/05/Linux%E9%83%A8%E5%88%86%E5%91%BD%E4%BB%A4/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Linux部分命令</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/10/24/Markdown%E8%AF%AD%E6%B3%95/" title="Markdown语法"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-24</div><div class="title">Markdown语法</div></div></a></div><div><a href="/2022/10/25/Ubuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85docker/" title="Ubuntu系统安装docker"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-25</div><div class="title">Ubuntu系统安装docker</div></div></a></div><div><a href="/2022/10/25/Ubuntu%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/" title="Ubuntu设置自动挂载硬盘"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-25</div><div class="title">Ubuntu设置自动挂载硬盘</div></div></a></div><div><a href="/2022/10/29/docker%E5%AE%B9%E5%99%A8%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4/" title="docker容器安装命令"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-29</div><div class="title">docker容器安装命令</div></div></a></div><div><a href="/2022/10/24/%E5%9C%A8macOS%E4%B8%AD%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%B3%BB%E7%BB%9F%E5%B9%B6%E5%86%99%E5%85%A5%E5%88%B0U%E7%9B%98/" title="在macOS中下载最新系统并写入到U盘"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-24</div><div class="title">在macOS中下载最新系统并写入到U盘</div></div></a></div><div><a href="/2022/10/24/%E5%9F%BA%E4%BA%8EDocker%E9%83%A8%E7%BD%B2OpenWrt/" title="基于Docker部署OpenWrt"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-24</div><div class="title">基于Docker部署OpenWrt</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-%E2%80%94%E2%80%94-%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98"><span class="toc-number">1.</span> <span class="toc-text">项目实战 —— 飞机大战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.</span> <span class="toc-text">实战步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AE%E8%AE%A4%E6%A8%A1%E5%9D%97-%E2%80%94%E2%80%94-pygame"><span class="toc-number">1.3.</span> <span class="toc-text">确认模块 —— pygame</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-pygame"><span class="toc-number">1.3.1.</span> <span class="toc-text">安装 pygame</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E5%AE%89%E8%A3%85"><span class="toc-number">1.3.2.</span> <span class="toc-text">验证安装</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pygame-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">2.</span> <span class="toc-text">pygame 快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-1"><span class="toc-number">2.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%87%86%E5%A4%87"><span class="toc-number">2.2.</span> <span class="toc-text">项目准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E4%BD%BF%E7%94%A8-pygame-%E5%88%9B%E5%BB%BA%E5%9B%BE%E5%BD%A2%E7%AA%97%E5%8F%A3"><span class="toc-number">2.3.</span> <span class="toc-text">01. 使用 pygame 创建图形窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E8%8A%82%E7%9B%AE%E6%A0%87"><span class="toc-number">2.3.1.</span> <span class="toc-text">小节目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%B8%B8%E6%88%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%80%80%E5%87%BA"><span class="toc-number">2.3.2.</span> <span class="toc-text">1.1 游戏的初始化和退出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%90%86%E8%A7%A3%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-number">2.3.3.</span> <span class="toc-text">1.2 理解游戏中的坐标系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%BB%83"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">案例演练</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%88%9B%E5%BB%BA%E6%B8%B8%E6%88%8F%E4%B8%BB%E7%AA%97%E5%8F%A3"><span class="toc-number">2.3.4.</span> <span class="toc-text">1.3 创建游戏主窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E7%AE%80%E5%8D%95%E7%9A%84%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.3.5.</span> <span class="toc-text">1.4 简单的游戏循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-%E7%90%86%E8%A7%A3-%E5%9B%BE%E5%83%8F-%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">02. 理解 图像 并实现图像绘制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%BB%83-I-%E2%80%94%E2%80%94-%E7%BB%98%E5%88%B6%E8%83%8C%E6%99%AF%E5%9B%BE%E5%83%8F"><span class="toc-number">2.4.1.</span> <span class="toc-text">代码演练 I —— 绘制背景图像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%BB%83-II-%E2%80%94%E2%80%94-%E7%BB%98%E5%88%B6%E8%8B%B1%E9%9B%84%E5%9B%BE%E5%83%8F"><span class="toc-number">2.4.2.</span> <span class="toc-text">代码演练 II —— 绘制英雄图像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-update-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.4.3.</span> <span class="toc-text">理解 update() 方法的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-%E7%90%86%E8%A7%A3-%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF-%E5%92%8C-%E6%B8%B8%E6%88%8F%E6%97%B6%E9%92%9F"><span class="toc-number">2.5.</span> <span class="toc-text">03. 理解 游戏循环 和 游戏时钟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.5.1.</span> <span class="toc-text">3.1 游戏中的动画实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.5.2.</span> <span class="toc-text">3.2 游戏循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">2.5.2.1.</span> <span class="toc-text">游戏的两个组成部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.5.2.2.</span> <span class="toc-text">游戏循环的作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%B8%B8%E6%88%8F%E6%97%B6%E9%92%9F"><span class="toc-number">2.5.3.</span> <span class="toc-text">3.3 游戏时钟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E8%8B%B1%E9%9B%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.5.4.</span> <span class="toc-text">3.4 英雄的简单动画实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A"><span class="toc-number">2.5.4.1.</span> <span class="toc-text">作业</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF%E4%B8%AD-%E7%9B%91%E5%90%AC-%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.5.5.</span> <span class="toc-text">3.5 在游戏循环中 监听 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6-event"><span class="toc-number">2.5.5.1.</span> <span class="toc-text">事件 event</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%AC"><span class="toc-number">2.5.5.2.</span> <span class="toc-text">监听</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.5.5.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-%E7%90%86%E8%A7%A3-%E7%B2%BE%E7%81%B5-%E5%92%8C-%E7%B2%BE%E7%81%B5%E7%BB%84"><span class="toc-number">2.6.</span> <span class="toc-text">04. 理解 精灵 和 精灵组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%B2%BE%E7%81%B5-%E5%92%8C-%E7%B2%BE%E7%81%B5%E7%BB%84"><span class="toc-number">2.6.1.</span> <span class="toc-text">4.1 精灵 和 精灵组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%BE%E7%81%B5"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">精灵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%BE%E7%81%B5%E7%BB%84"><span class="toc-number">2.6.1.2.</span> <span class="toc-text">精灵组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%B4%BE%E7%94%9F%E7%B2%BE%E7%81%B5%E5%AD%90%E7%B1%BB"><span class="toc-number">2.6.2.</span> <span class="toc-text">4.2 派生精灵子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%BD%BF%E7%94%A8-%E6%B8%B8%E6%88%8F%E7%B2%BE%E7%81%B5-%E5%92%8C-%E7%B2%BE%E7%81%B5%E7%BB%84-%E5%88%9B%E5%BB%BA%E6%95%8C%E6%9C%BA"><span class="toc-number">2.6.3.</span> <span class="toc-text">4.3 使用 游戏精灵 和 精灵组 创建敌机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.6.3.1.</span> <span class="toc-text">实现步骤</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA"><span class="toc-number">3.</span> <span class="toc-text">游戏框架搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-2"><span class="toc-number">3.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E6%98%8E%E7%A1%AE%E4%B8%BB%E7%A8%8B%E5%BA%8F%E8%81%8C%E8%B4%A3"><span class="toc-number">3.2.</span> <span class="toc-text">01. 明确主程序职责</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-%E5%AE%9E%E7%8E%B0%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98%E4%B8%BB%E6%B8%B8%E6%88%8F%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">02. 实现飞机大战主游戏类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%98%8E%E7%A1%AE%E6%96%87%E4%BB%B6%E8%81%8C%E8%B4%A3"><span class="toc-number">3.3.1.</span> <span class="toc-text">2.1 明确文件职责</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%B8%B8%E6%88%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%83%A8%E5%88%86"><span class="toc-number">3.3.2.</span> <span class="toc-text">2.3 游戏初始化部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-%E5%B8%B8%E9%87%8F-%E4%BB%A3%E6%9B%BF%E5%9B%BA%E5%AE%9A%E7%9A%84%E6%95%B0%E5%80%BC"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">使用 常量 代替固定的数值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF%E9%83%A8%E5%88%86"><span class="toc-number">3.3.3.</span> <span class="toc-text">2.4 游戏循环部分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-%E5%87%86%E5%A4%87%E6%B8%B8%E6%88%8F%E7%B2%BE%E7%81%B5%E7%BB%84"><span class="toc-number">3.4.</span> <span class="toc-text">03. 准备游戏精灵组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%A1%AE%E5%AE%9A%E7%B2%BE%E7%81%B5%E7%BB%84"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.1 确定精灵组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.2 代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E8%83%8C%E6%99%AF"><span class="toc-number">4.</span> <span class="toc-text">游戏背景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-3"><span class="toc-number">4.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E8%83%8C%E6%99%AF%E4%BA%A4%E6%9B%BF%E6%BB%9A%E5%8A%A8%E7%9A%84%E6%80%9D%E8%B7%AF%E7%A1%AE%E5%AE%9A"><span class="toc-number">4.2.</span> <span class="toc-text">01. 背景交替滚动的思路确定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="toc-number">4.2.1.</span> <span class="toc-text">1.1 实现思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E8%AE%BE%E8%AE%A1%E8%83%8C%E6%99%AF%E7%B1%BB"><span class="toc-number">4.2.2.</span> <span class="toc-text">1.2 设计背景类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-%E6%98%BE%E7%A4%BA%E6%B8%B8%E6%88%8F%E8%83%8C%E6%99%AF"><span class="toc-number">4.3.</span> <span class="toc-text">02. 显示游戏背景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%83%8C%E6%99%AF%E7%B2%BE%E7%81%B5%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text">2.1 背景精灵的基本实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%9C%A8-plane-main-py-%E4%B8%AD%E6%98%BE%E7%A4%BA%E8%83%8C%E6%99%AF%E7%B2%BE%E7%81%B5"><span class="toc-number">4.3.2.</span> <span class="toc-text">2.2 在 plane_main.py 中显示背景精灵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%88%A9%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95%EF%BC%8C%E7%AE%80%E5%8C%96%E8%83%8C%E6%99%AF%E7%B2%BE%E7%81%B5%E5%88%9B%E5%BB%BA"><span class="toc-number">4.3.3.</span> <span class="toc-text">2.3 利用初始化方法，简化背景精灵创建</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%8C%E6%9C%BA%E5%87%BA%E5%9C%BA"><span class="toc-number">5.</span> <span class="toc-text">敌机出场</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-4"><span class="toc-number">5.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%95%8C%E6%9C%BA"><span class="toc-number">5.2.</span> <span class="toc-text">01. 使用定时器添加敌机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">5.2.1.</span> <span class="toc-text">1.1 定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%AE%9A%E4%B9%89%E5%B9%B6%E7%9B%91%E5%90%AC%E5%88%9B%E5%BB%BA%E6%95%8C%E6%9C%BA%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.2.2.</span> <span class="toc-text">1.2 定义并监听创建敌机的定时器事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">1) 定义事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%9B%91%E5%90%AC%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">2) 监听定时器事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-%E8%AE%BE%E8%AE%A1-Enemy-%E7%B1%BB"><span class="toc-number">5.3.</span> <span class="toc-text">02. 设计 Enemy 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%95%8C%E6%9C%BA%E7%B1%BB%E7%9A%84%E5%87%86%E5%A4%87"><span class="toc-number">5.3.1.</span> <span class="toc-text">2.1 敌机类的准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%88%9B%E5%BB%BA%E6%95%8C%E6%9C%BA"><span class="toc-number">5.3.2.</span> <span class="toc-text">2.2 创建敌机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%9A%8F%E6%9C%BA%E6%95%8C%E6%9C%BA%E4%BD%8D%E7%BD%AE%E5%92%8C%E9%80%9F%E5%BA%A6"><span class="toc-number">5.3.3.</span> <span class="toc-text">2.3 随机敌机位置和速度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97"><span class="toc-number">5.3.3.1.</span> <span class="toc-text">1) 导入模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9A%8F%E6%9C%BA%E4%BD%8D%E7%BD%AE"><span class="toc-number">5.3.3.2.</span> <span class="toc-text">2) 随机位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.3.3.3.</span> <span class="toc-text">3) 代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%A7%BB%E5%87%BA%E5%B1%8F%E5%B9%95%E9%94%80%E6%AF%81%E6%95%8C%E6%9C%BA"><span class="toc-number">5.3.4.</span> <span class="toc-text">2.4 移出屏幕销毁敌机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%95%8C%E6%9C%BA%E8%A2%AB%E9%94%80%E6%AF%81"><span class="toc-number">5.3.4.1.</span> <span class="toc-text">检测敌机被销毁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">5.3.4.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8B%B1%E9%9B%84%E7%99%BB%E5%9C%BA"><span class="toc-number">6.</span> <span class="toc-text">英雄登场</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-5"><span class="toc-number">6.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E8%AE%BE%E8%AE%A1-%E8%8B%B1%E9%9B%84-%E5%92%8C-%E5%AD%90%E5%BC%B9-%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">01. 设计 英雄 和 子弹 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8B%B1%E9%9B%84%E9%9C%80%E6%B1%82"><span class="toc-number">6.2.1.</span> <span class="toc-text">英雄需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%BC%B9%E9%9C%80%E6%B1%82"><span class="toc-number">6.2.2.</span> <span class="toc-text">子弹需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hero-%E2%80%94%E2%80%94-%E8%8B%B1%E9%9B%84"><span class="toc-number">6.2.3.</span> <span class="toc-text">Hero —— 英雄</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bullet-%E2%80%94%E2%80%94-%E5%AD%90%E5%BC%B9"><span class="toc-number">6.2.4.</span> <span class="toc-text">Bullet —— 子弹</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-%E5%88%9B%E5%BB%BA%E8%8B%B1%E9%9B%84"><span class="toc-number">6.3.</span> <span class="toc-text">02. 创建英雄</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%87%86%E5%A4%87%E8%8B%B1%E9%9B%84%E7%B1%BB"><span class="toc-number">6.3.1.</span> <span class="toc-text">2.1 准备英雄类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%BB%98%E5%88%B6%E8%8B%B1%E9%9B%84"><span class="toc-number">6.3.2.</span> <span class="toc-text">2.2 绘制英雄</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-%E7%A7%BB%E5%8A%A8%E8%8B%B1%E9%9B%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">6.4.</span> <span class="toc-text">03. 移动英雄位置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%A7%BB%E5%8A%A8%E8%8B%B1%E9%9B%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">6.4.1.</span> <span class="toc-text">3.1 移动英雄位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%8E%A7%E5%88%B6%E8%8B%B1%E9%9B%84%E8%BF%90%E5%8A%A8%E8%BE%B9%E7%95%8C"><span class="toc-number">6.4.2.</span> <span class="toc-text">3.2 控制英雄运动边界</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-%E5%8F%91%E5%B0%84%E5%AD%90%E5%BC%B9"><span class="toc-number">6.5.</span> <span class="toc-text">04. 发射子弹</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%9B%9E%E9%A1%BE-%E2%80%94%E2%80%94-%E8%8B%B1%E9%9B%84%E9%9C%80%E6%B1%82"><span class="toc-number">6.5.1.</span> <span class="toc-text">需求回顾 —— 英雄需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%B7%BB%E5%8A%A0%E5%8F%91%E5%B0%84%E5%AD%90%E5%BC%B9%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.5.2.</span> <span class="toc-text">4.1 添加发射子弹事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%AE%9A%E4%B9%89%E5%AD%90%E5%BC%B9%E7%B1%BB"><span class="toc-number">6.5.3.</span> <span class="toc-text">4.2 定义子弹类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%9B%9E%E9%A1%BE-%E2%80%94%E2%80%94-%E5%AD%90%E5%BC%B9%E9%9C%80%E6%B1%82"><span class="toc-number">6.5.3.1.</span> <span class="toc-text">需求回顾 —— 子弹需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bullet-%E2%80%94%E2%80%94-%E5%AD%90%E5%BC%B9-1"><span class="toc-number">6.5.3.2.</span> <span class="toc-text">Bullet —— 子弹</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%AD%90%E5%BC%B9%E7%B1%BB"><span class="toc-number">6.5.3.3.</span> <span class="toc-text">定义子弹类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%8F%91%E5%B0%84%E5%AD%90%E5%BC%B9"><span class="toc-number">6.5.4.</span> <span class="toc-text">4.3 发射子弹</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E5%8F%91%E5%B0%84%E4%B8%89%E6%9E%9A%E5%AD%90%E5%BC%B9"><span class="toc-number">6.5.4.1.</span> <span class="toc-text">一次发射三枚子弹</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B"><span class="toc-number">7.</span> <span class="toc-text">碰撞检测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-6"><span class="toc-number">7.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E4%BA%86%E8%A7%A3%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.</span> <span class="toc-text">01. 了解碰撞检测方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pygame-sprite-groupcollide"><span class="toc-number">7.2.1.</span> <span class="toc-text">pygame.sprite.groupcollide()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pygame-sprite-spritecollide"><span class="toc-number">7.2.2.</span> <span class="toc-text">pygame.sprite.spritecollide()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-%E7%A2%B0%E6%92%9E%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.3.</span> <span class="toc-text">02. 碰撞实现</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/29/docker%E5%AE%B9%E5%99%A8%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4/" title="docker容器安装命令"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="docker容器安装命令"/></a><div class="content"><a class="title" href="/2022/10/29/docker%E5%AE%B9%E5%99%A8%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4/" title="docker容器安装命令">docker容器安装命令</a><time datetime="2022-10-29T14:09:45.000Z" title="Created 2022-10-29 22:09:45">2022-10-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/25/Ubuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85docker/" title="Ubuntu系统安装docker"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ubuntu系统安装docker"/></a><div class="content"><a class="title" href="/2022/10/25/Ubuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85docker/" title="Ubuntu系统安装docker">Ubuntu系统安装docker</a><time datetime="2022-10-25T14:09:45.000Z" title="Created 2022-10-25 22:09:45">2022-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/25/Ubuntu%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/" title="Ubuntu设置自动挂载硬盘"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ubuntu设置自动挂载硬盘"/></a><div class="content"><a class="title" href="/2022/10/25/Ubuntu%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/" title="Ubuntu设置自动挂载硬盘">Ubuntu设置自动挂载硬盘</a><time datetime="2022-10-25T14:09:45.000Z" title="Created 2022-10-25 22:09:45">2022-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/24/Markdown%E8%AF%AD%E6%B3%95/" title="Markdown语法"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Markdown语法"/></a><div class="content"><a class="title" href="/2022/10/24/Markdown%E8%AF%AD%E6%B3%95/" title="Markdown语法">Markdown语法</a><time datetime="2022-10-24T14:09:45.000Z" title="Created 2022-10-24 22:09:45">2022-10-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/24/%E5%9C%A8macOS%E4%B8%AD%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%B3%BB%E7%BB%9F%E5%B9%B6%E5%86%99%E5%85%A5%E5%88%B0U%E7%9B%98/" title="在macOS中下载最新系统并写入到U盘"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="在macOS中下载最新系统并写入到U盘"/></a><div class="content"><a class="title" href="/2022/10/24/%E5%9C%A8macOS%E4%B8%AD%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%B3%BB%E7%BB%9F%E5%B9%B6%E5%86%99%E5%85%A5%E5%88%B0U%E7%9B%98/" title="在macOS中下载最新系统并写入到U盘">在macOS中下载最新系统并写入到U盘</a><time datetime="2022-10-24T14:09:45.000Z" title="Created 2022-10-24 22:09:45">2022-10-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>